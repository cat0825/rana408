---
{"dg-publish":true,"dg-permalink":"/408/目录文件与inode节点","permalink":"/408/目录文件与inode节点/"}
---


## 目录文件在文件系统当中的作用
目录文件主要作用包括：

1. **实现文件的按名存取**：这是目录最基本的功能。用户通过文件名来访问文件，而目录负责将文件名映射到文件在存储设备上的物理位置。
    
2. **文件系统的层次结构组织**：通过目录的嵌套（如树形目录结构），用户可以将大量文件组织成逻辑清晰、易于查找的层次结构，方便用户管理和查找文件。
    
3. **实现文件共享**：通过目录中的硬链接（Hard Link）或软链接（Symbolic Link/Soft Link），可以实现文件的共享，让多个用户或程序通过不同的路径名访问同一个文件。
    
4. **提供文件属性信息**：目录项除了包含文件名和指向文件物理位置的指针，通常还包含文件的其他属性信息，如文件类型、大小、创建时间、修改时间、访问权限等。
    
5. **提高文件系统效率**：通过合理的目录组织和查找机制，可以加快文件的查找速度。
    

---



## 目录文件是怎么实现的？（如何存放文件名和文件信息）
操作系统并不会把文件的所有内容都直接塞进目录文件里。目录文件本身是一种特殊类型的文件，它**存储的是目录项的集合**。每个**目录项（Directory Entry）**通常包含两部分核心信息：

1. **文件名（File Name）**：用户可见的文件名。
    
2. **文件描述符的指针/索引（Pointer/Index to File Descriptor）**：这不是直接指向文件内容的物理地址，而是指向**文件控制块（File Control Block, FCB）的指针或索引。

### 核心概念：文件控制块（FCB）和 i-node
FCB 是文件系统中存储文件**所有属性信息和物理位置信息**的核心数据结构。为了解决“总不能把文件名全部写进去吧”的问题，现代文件系统普遍采用了**目录文件与 FCB（或 i-node）分离**的实现方式。

#### 1. 文件控制块 (FCB) / i-node
- **FCB（File Control Block）**：包含了文件所有基本信息和属性，包括：
    
    - **文件拥有者ID**
        
    - **文件类型**（普通文件、目录、设备文件等）
        
    - **访问权限**（读/写/执行权限）
        
    - **创建时间、最后修改时间、最后访问时间**
        
    - **文件大小**
        
    - **文件实际数据的物理地址信息**（这是最重要的，通常通过链接分配、索引分配等方式来记录数据块的指针）。
        
    - **链接计数**（有多少个目录项指向这个FCB）。
        
- **i-node（索引节点，Inception Node）**：在 Unix/Linux 等类Unix系统中，FCB 通常被称为 **i-node**。i-node 是一个**固定大小的数据结构**，每个文件（包括目录文件本身）都有一个唯一的 i-node。
    
    - **i-node 不包含文件名**，它只包含文件除了文件名之外的所有属性和物理地址信息。
        
    - 每个 i-node 都有一个唯一的**i-node 号（i-number）**，它是文件系统内部用来唯一标识文件的整数。


#### 2. 目录文件的具体实现
目录文件本身就像一张**两列的表格**：

|文件名 (File Name)|i-node 号 (i-number) / FCB 指针|
|---|---|
|file_a.txt|100|
|my_document.doc|205|
|new_directory/|312|
|...|...|

- 当用户创建一个文件时，文件系统会：
    
    1. 在**空闲 i-node 列表**中找到一个未使用的 i-node，并为其分配一个 i-node 号。
        
    2. 在新的 i-node 中写入文件的各种属性信息和**文件数据块的物理地址**。
        
    3. 在**父目录文件**中添加一个新的**目录项**，这个目录项包含新文件的**文件名**和它所对应的**i-node 号**。
        
- 当用户通过文件名访问文件时（例如，`open("/home/user/document.txt")`）：
    
    1. 文件系统首先查找 `/home` 目录文件，找到 `user` 目录对应的 i-node 号。
        
    2. 根据 `user` 目录的 i-node 号，读取 `user` 目录文件内容。
        
    3. 在 `user` 目录文件内容中查找 `document.txt` 这个文件名，并获取它对应的 i-node 号。
        
    4. 根据 `document.txt` 的 i-node 号，读取对应的 i-node 内容，从中获取文件的物理地址信息以及权限等属性。
        
    5. 最终，文件系统根据 i-node 中的物理地址信息，定位到文件数据所在的磁盘块并进行读写操作。


### 为什么这样做？（目录与FCB/i-node分离的优点）
1. **解决了“文件名全部写进去”的问题**：目录文件只存储文件名和指向FCB/i-node的短指针/索引，而不是文件的所有属性和内容。这使得目录文件更小、更易于管理。
    
2. **提高了查找效率**：当查找文件时，只需扫描目录文件中的文件名和i-node号，而不需要读取所有文件的全部信息。一旦找到i-node号，就可以直接定位到FCB/i-node。
    
3. **实现文件共享（硬链接）**：多个目录项可以指向同一个FCB/i-node。这样，即使文件有多个名称或在多个目录下可见，文件本身在磁盘上只有一份数据和一份FCB/i-node。当删除一个目录项时，只有当所有指向该i-node的链接计数为零时，文件数据和i-node才会被真正删除。
    
4. **支持长文件名**：目录项中存储的文件名长度通常是固定的或有最大限制的。如果文件名过长，目录项可能只存储文件名的一部分或一个指向实际文件名的指针，而实际文件名可能存储在其他地方（如FCB的某个区域或单独的文件名存储区）。
    
5. **简化文件管理**：文件系统的各种管理操作（如文件删除、重命名）只需修改目录项和/或FCB/i-node，而无需移动文件数据。


### 补充图示：
```
+------------------+     +------------------------+      +------------------+
|    根目录文件    |     |      用户目录文件      |      |   数据块 (Disk)  |
| (目录项集合)     |     |      (目录项集合)      |      | +-------------+ |
|                  |     |                        |      | |文件内容...  | |
|  "home" -> 101 --|---->|  "user" -> 203 --------|----->| +-------------+ |
|  "boot" -> 102    |     |  "docs" -> 204         |      | |文件内容...  | |
|  ...             |     |  "file.txt" -> 305 ----|---+  | +-------------+ |
+------------------+     +------------------------+   |  +------------------+
                                                      |
                                                      |  +------------------+
                                                      +->|    i-node 305    |
                                                         |------------------|
                                                         | 文件类型: 普通文件 |
                                                         | 大小: 10KB       |
                                                         | 权限: rw-r--r--  |
                                                         | 创建时间: ...    |
                                                         | 数据块指针:      |
                                                         |   -> 物理块A      |
                                                         |   -> 物理块B      |
                                                         |   ...            |
                                                         +------------------+
```



## 补充图示：FCB/i-node 与目录文件关系
**FCB 和 i-node 都是存储文件的元数据（Metadata）的核心数据结构，它们与目录文件之间存在清晰的分离。**

以下我们将通过表格和文字说明，详细阐述它们之间的关系。

**假设一个文件系统包含以下文件和目录：**

- 根目录 `/` (i-node 1)
    
- `/home` 目录 (i-node 10)
    
- `/home/user` 目录 (i-node 20)
    
- `/home/user/document.txt` 文件 (i-node 100)
    
- `/home/user/my_link` (指向 `/home/user/document.txt` 的硬链接)
    

---

### 1. 目录文件内容示例：
目录文件本身是一种特殊类型的文件，它**存储的是目录项的集合**。每个**目录项（Directory Entry）**通常包含两部分核心信息：**文件名** 和 指向**文件描述符的指针/索引（FCB/i-node 号）**。

**a. 根目录文件 `/` 的内容 (对应 i-node 1)**

|文件名|i-node 号 (或 FCB 指针)|
|---|---|
|`.`|1|
|`..`|1|
|`home`|10|
|`bin`|5|
|`etc`|7|

**b. `/home` 目录文件 `/home/` 的内容 (对应 i-node 10)**

|文件名|i-node 号 (或 FCB 指针)|
|---|---|
|`.`|10|
|`..`|1|
|`user`|20|
|`public`|25|

**c. `/home/user` 目录文件 `/home/user/` 的内容 (对应 i-node 20)**

|文件名|i-node 号 (或 FCB 指针)|
|---|---|
|`.`|20|
|`..`|10|
|`document.txt`|100|
|`my_link`|100|

---


### 2. FCB/i-node 表示例：
这是一个存储所有 FCB 或 i-node 的区域，通常位于磁盘的特定区域。每个 FCB/i-node 存储了文件的所有元数据和物理地址信息，但**不包含文件名**（特别是 i-node）。

**a. i-node 号 1 (对应根目录 `/`)**

|属性|值|
|---|---|
|**文件类型**|目录 (Directory)|
|**权限**|`rwxr-xr-x`|
|**拥有者**|`root`|
|**组**|`root`|
|**链接计数**|3 (被 `/` 自身、`/home/..` 和 `/user/..` 指向)|
|**大小**|128 bytes (目录项所占空间)|
|**创建时间**|`2024-01-01 10:00:00`|
|**修改时间**|`2024-06-30 12:00:00`|
|**访问时间**|`2025-06-30 12:25:00`|
|**数据块指针**|扇区 A, 扇区 B (存储根目录的目录项)|

**b. i-node 号 10 (对应 `/home` 目录)**

|属性|值|
|---|---|
|**文件类型**|目录 (Directory)|
|**权限**|`rwxr-xr-x`|
|**拥有者**|`root`|
|**组**|`root`|
|**链接计数**|3 (被 `/home` 自身、`/home/user/..` 和 `/home/public/..` 指向)|
|**大小**|128 bytes (目录项所占空间)|
|**创建时间**|`2024-01-05 15:30:00`|
|**修改时间**|`2025-06-30 12:05:00`|
|**访问时间**|`2025-06-30 12:26:00`|
|**数据块指针**|扇区 C, 扇区 D (存储 `/home` 目录的目录项)|

**c. i-node 号 20 (对应 `/home/user` 目录)**

|属性|值|
|---|---|
|**文件类型**|目录 (Directory)|
|**权限**|`rwxr-xr-x`|
|**拥有者**|`user`|
|**组**|`users`|
|**链接计数**|3 (被 `/home/user` 自身、`/home/user/document.txt/.` 和 `/home/user/my_link/.` 指向)|
|**大小**|64 bytes (目录项所占空间)|
|**创建时间**|`2024-02-10 11:00:00`|
|**修改时间**|`2025-06-30 12:10:00`|
|**访问时间**|`2025-06-30 12:27:00`|
|**数据块指针**|扇区 E (存储 `/home/user` 目录的目录项)|

**d. i-node 号 100 (对应 `/home/user/document.txt` 文件)**

|属性|值|
|---|---|
|**文件类型**|普通文件 (Regular File)|
|**权限**|`rw-r--r--`|
|**拥有者**|`user`|
|**组**|`users`|
|**链接计数**|**2** (被 `/home/user/document.txt` 和 `/home/user/my_link` 指向)|
|**大小**|4096 bytes|
|**创建时间**|`2024-03-15 09:00:00`|
|**修改时间**|`2025-06-29 18:30:00`|
|**访问时间**|`2025-06-30 12:20:00`|
|**数据块指针**|扇区 X, 扇区 Y (存储文件数据内容的物理地址)|

---



## FCB 和 i-node 之间有什么区别？
**是的，FCB 和 i-node 都是用于存储文件元数据（Metadata）的核心数据结构。

### 核心区别：
1. **名称和系统背景**：
    
    - **FCB (File Control Block)**：这是一个**更通用、更抽象的操作系统概念**，泛指操作系统中用于管理文件所有信息的数据结构。在许多文件系统（包括一些早期的系统或 Windows 的 NTFS 文件系统内部）中，都会有类似FCB的结构来维护文件的元数据。
        
    - **i-node (Inception Node / Index Node)**：这是 **Unix/Linux 文件系统（如 ext2/3/4、XFS 等）中 FCB 的具体、标志性实现**。它是 Unix/Linux 文件系统设计的核心和基石。
        
2. **是否直接包含文件名**：
    
    - **FCB (在某些传统或简化实现中)**：在一些早期或简化实现的文件系统中，FCB 可能**直接包含文件名**。在这种情况下，目录文件就直接存储一系列 FCB，或者指向 FCB 的指针。
        
    - **i-node**：**i-node 本身不包含文件名。** 文件名是存储在**目录文件**中，作为目录项的一部分，并与它所指向的 i-node 号关联。这是 i-node 设计的**一个非常重要的特点**，也是其优势所在。



## 如果使用了 FCB 或者 i-node 的话，目录文件是不是只需要存储文件名和对应的 FCB/i-node 编号？
**是的，您的理解完全正确！**

正如上面表格和详细解释所示：

- 当文件系统采用 **FCB 或 i-node 分离**的设计时，**目录文件**的核心任务就是存储**文件名**和与该文件名对应的 **FCB 指针**（在 Unix/Linux 系统中是 **i-node 号**）。
    
- **文件名**是用户用于识别和访问文件的逻辑名称。
    
- **FCB 指针/i-node 号**是文件系统内部用于定位文件元数据（以及通过元数据定位文件数据）的唯一标识符。



## FCB 和 i-node 存储在哪里？磁盘吗？
**是的，FCB 和 i-node 最终都存储在磁盘上。** 它们是文件系统的**元数据**，需要持久化保存，以便在系统重启后文件系统依然能够正确地组织和识别文件。

- **在磁盘上的具体位置：**
    
    - **FCB**：对于一些文件系统（如早期FAT文件系统）可能将FCB与目录项紧密结合，甚至直接存放在目录文件中。而更现代的文件系统（如NTFS）会有专门的元数据区来存放FCB。
        
    - **i-node**：在 Unix/Linux 文件系统中，磁盘通常会被划分为多个**柱面组（Cylinder Group）**或**块组（Block Group）**。每个柱面组内部会有专门的区域来存放**i-node表（i-node Table）**。这个 i-node 表就是所有 i-node 的集合。
        

**总结：** 它们是文件系统数据结构的一部分，存储在磁盘上的**特定区域（元数据区）**，与文件数据区域是分开的。

---



## FCB 和 i-node 需要连续吗？
**通常情况下，磁盘上的 FCB 或 i-node 区域是采用连续分配的方式进行管理的。**

- **FCB/i-node 本身的大小是固定的。**
    
- **i-node 表**：在 Unix/Linux 文件系统中，i-node 表是一个**连续的区域**，其中每个 i-node 的大小是固定的。这使得通过 i-node 号可以非常方便地计算出某个 i-node 在磁盘 i-node 表中的精确物理位置：`i-node地址 = i-node表起始地址 + (i-node号 - 1) * i-node大小`。这种连续性有助于快速定位和访问 i-node。
    

**需要区分的是：**

- **FCB/i-node 本身（元数据）是连续存储的。**
    
- **文件数据块**：FCB/i-node 中存储的是文件数据块的**物理地址**。文件数据块本身在磁盘上**可以是不连续的**（通过链接分配或索引分配实现），这与 FCB/i-node 的连续性是两回事。FCB/i-node 内部的**指针列表**记录了不连续数据块的地址。
    

---



## 这个区域都可以被什么访问呢？
FCB 和 i-node 所在的磁盘区域（元数据区）是文件系统的核心，其访问权限受到严格控制。

1. **操作系统内核（Kernel）**：
    
    - 这是**唯一能够直接**访问和修改 FCB/i-node 区域的实体。
        
    - **原因**：文件系统的完整性、一致性和安全性都依赖于对这些元数据的正确管理。任何不当的修改都可能导致文件系统损坏、数据丢失或安全漏洞。
        
    - 当用户进程需要对文件进行操作（如创建、删除、修改、读取属性等）时，它必须通过**系统调用**向操作系统内核发出请求。内核在**特权模式（内核态）**下执行这些操作，负责访问并更新 FCB/i-node。
        
2. **文件系统驱动**：
    
    - 文件系统是操作系统内核的一部分或一个内核模块。文件系统驱动（例如，Linux 下的 ext4 驱动、Windows 下的 NTFS 驱动）是负责将逻辑文件操作转换为磁盘物理操作的软件组件。它直接负责 FCB/i-node 的读写。
        
3. **磁盘控制器/硬件**：
    
    - 最终，操作系统通过向磁盘控制器发送命令来实际读取或写入磁盘上的 FCB/i-node 数据。
        

**总结：** 用户进程**不能直接**访问或修改磁盘上的 FCB/i-node 区域。它们必须通过操作系统提供的**系统调用接口**来间接操作文件，由操作系统内核来执行对 FCB/i-node 的实际访问和修改。

---



## 需要内核级才能访问吗？
**是的，FCB 和 i-node 所在的区域（以及它们内部的结构）只有在**内核态（Kernel Mode）**下才能被直接访问和修改。**

- **用户态（User Mode）** 程序：
    
    - **无法直接**读取或修改 FCB/i-node。
        
    - 只能通过标准的文件操作函数（如 `open()`, `read()`, `write()`, `stat()`, `mkdir()`, `rm()` 等）来请求操作系统进行相关操作。
        
    - 这些函数都是**系统调用（System Calls）**，会触发特权级切换，将CPU从用户态切换到内核态，由内核来完成实际的操作。
        
- **内核态（Kernel Mode）**：
    
    - 操作系统内核代码在内核态下运行，拥有最高的权限，可以直接访问所有硬件资源和内存区域，包括磁盘上的 FCB/i-node 区域。
        
    - 所有对文件系统的管理和维护（如分配新的 i-node、更新文件大小、修改权限、处理硬链接计数等）都是在内核态下完成的。
        

**这是操作系统安全和文件系统完整性的基本保障。** 想象一下，如果用户程序可以随意修改 i-node，那么它就可以轻易篡改文件权限、大小，甚至指向其他文件的物理地址，这将导致严重的安全漏洞和文件系统崩溃。



## FAT 文件系统目录项的构成
在 FAT (File Allocation Table) 文件系统中，**目录项（Directory Entry）是一个固定大小的结构（通常为 32 字节）**。它直接存储了文件的**文件名**以及文件的**大部分元数据（FCB 的一部分）**，并且还包含了指向文件第一个数据簇的指针。

一个典型的 FAT 目录项包含以下主要字段：

1. **文件名（File Name）**：
    
    - **大小**：8 字节。
        
    - **内容**：文件的主文件名，ASCII 字符，不足 8 字节用空格填充。
        
    - **特点**：**短文件名 (8.3 格式)**。例如 `MYDOC.TXT`，`8` 是主文件名，`.` 是分隔符，`3` 是扩展名。
        
        - 第一个字节还有特殊含义：如果为 `0xE5` 表示文件已删除；如果为 `0x00` 表示该目录项及其后续项都为空。
            
        - 注意：为了支持长文件名 (Long File Name, LFN)，FAT 引入了复杂的扩展机制，即 LFN 目录项，它们是多个 32 字节目录项的组合，用于存储长文件名，并指向一个“真实”的 8.3 格式短文件名目录项。但核心的文件元数据仍存储在 8.3 格式的目录项中。
            
2. **文件扩展名（File Extension）**：
    
    - **大小**：3 字节。
        
    - **内容**：文件的扩展名，ASCII 字符，不足 3 字节用空格填充。
        
3. **文件属性字节（File Attributes）**：
    
    - **大小**：1 字节。
        
    - **内容**：一个位图，用于指示文件的各种属性。常见的属性位包括：
        
        - **只读（Read-Only）**
            
        - **隐藏（Hidden）**
            
        - **系统（System）**
            
        - **卷标（Volume Label）**：如果设置此位，表示这是一个卷标目录项，而不是文件或目录。
            
        - **目录（Directory）**：如果设置此位，表示该目录项代表一个子目录。
            
        - **存档（Archive）**：表示文件自上次备份后是否被修改过。
            
        - **设备（Device）**：表示一个设备（不常用）。
            
        - **LFN（Long File Name）**：如果设置了，表示这是一个长文件名条目。
            
4. **保留字节（Reserved）**：
    
    - **大小**：10 字节。
        
    - **内容**：保留供未来使用。在 FAT32 中，这部分被用于存储文件创建时间毫秒、最后访问日期等信息。
        
5. **文件创建时间（Create Time）**：
    
    - **大小**：2 字节。
        
    - **内容**：精确到秒。
        
6. **文件创建日期（Create Date）**：
    
    - **大小**：2 字节。
        
7. **最后访问日期（Last Access Date）**：
    
    - **大小**：2 字节。
        
8. **忽略（Ignored for FAT12/16）/高 16 位簇号（FAT32）**：
    
    - **大小**：2 字节。
        
    - **内容**：在 FAT12/16 中未使用。在 FAT32 中，存储文件第一个数据簇号的高 16 位（因为 FAT32 簇号是 32 位的）。
        
9. **最后修改时间（Last Write Time）**：
    
    - **大小**：2 字节。
        
10. **最后修改日期（Last Write Date）**：
    
    - **大小**：2 字节。
        
11. **文件第一个簇号（First Cluster Number）**：
    
    - **大小**：2 字节。
        
    - **内容**：存储文件数据在数据区中**第一个数据簇的编号**。这是非常关键的，因为文件系统通过这个簇号在**文件分配表（FAT 表）**中查找文件的后续数据簇。
        
    - **特点**：对于 FAT32，这里只存储簇号的低 16 位。
        
12. **文件大小（File Size）**：
    
    - **大小**：4 字节。
        
    - **内容**：以字节为单位存储文件的大小。

### FAT 目录项的结构示意图（32字节）
```
+-------------------------------------------------+
| 0        1        2        3        4        5        6        7        8        9        A        B  ... | (字节偏移)
|----------------------------------------------------------------------------------------------------------------|
|          文件名 (8字节)         | 扩展名 (3字节) | 属性 (1字节) | 保留 (10字节) (FAT32高16位簇号) | 创建时间 (2字节) | 创建日期 (2字节) | 最后访问日期 (2字节) | 最后修改时间 (2字节) | 最后修改日期 (2字节) | 第一个簇号 (2字节) | 文件大小 (4字节) |
+-------------------------------------------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
```


### FAT 文件系统的特点及与 i-node 系统的对比：
| 特性           | FAT 文件系统 (如 FAT32) 的目录项        | Unix/Linux 文件系统 (i-node) 的目录项            |
| ------------ | ------------------------------ | ---------------------------------------- |
| **包含内容**     | **文件名 + 大部分文件元数据 + 第一个数据簇号**   | **文件名 + 对应的 i-node 号**                   |
| **大小**       | 固定 32 字节 (不含 LFN 扩展)           | 通常固定大小 (如 16 或 24 字节)                    |
| **元数据存储**    | **直接存储在目录项中**                  | **独立存储在 i-node 中**                       |
| **文件删除/重命名** | 删除需标记目录项，并清空 FAT 表项。重命名需修改目录项。 | 删除仅减 i-node 引用计数。重命名仅修改目录项。              |
| **硬链接**      | **不支持** (因为文件名和元数据是绑定的)        | **支持** (多个目录项可指向同一个 i-node)              |
| **灵活性**      | 相对较低，目录项庞大，不适合复杂共享             | 较高，分离设计灵活，支持硬链接，易于管理                     |
| **查找文件信息**   | 找到目录项即可获取大部分元数据                | 找到目录项 -> 获取 i-node 号 -> 查找 i-node 表获取元数据 |


### 总结：
FAT 文件系统的目录项设计相对简单粗暴，将文件名和大部分文件元数据直接捆绑在一起，这使得它易于理解和实现。然而，这种设计也带来了一些限制，如不支持硬链接，且文件操作（特别是涉及元数据的修改）可能需要直接操作目录项，不如 i-node 系统的分离设计灵活和高效。
