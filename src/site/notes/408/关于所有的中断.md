---
{"dg-publish":true,"dg-permalink":"/408/关于所有的中断","permalink":"/408/关于所有的中断/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

### 中断的分类：内中断与外中断
在计算机系统中，中断是CPU暂停当前执行的程序，转而处理紧急事件的一种机制。根据中断事件的来源，中断可以分为**内中断**和**外中断**。


#### 详细讲解：
1. **外中断 (External Interrupts)**：
    
    - **定义**：指来源于CPU外部、与当前正在执行的程序**无关**的事件所引起的中断。这些中断通常是异步发生的。
    - **特点**：由外部设备或定时器产生，是CPU被动接收的信号。
    - **常见类型**：
        - **I/O 中断**：当输入/输出设备完成数据传输、发生错误或需要CPU介入时产生。例如，打印机完成打印任务、硬盘完成数据读取、键盘输入数据等。
        - **时钟中断**：由硬件定时器（时钟芯片）周期性地产生，用于操作系统的**时间片轮转调度**、更新系统时间、实现延时功能等。
        - **人工中断**：如用户按下Ctrl+C组合键强制终止程序，通常会产生一个中断信号。
        - **电源故障中断**：当系统检测到电源电压异常时产生，以便系统进行紧急处理。
2. **内中断 (Internal Interrupts / Exceptions)**：
    
    - **定义**：指来源于CPU内部、与当前正在执行的程序**有关**的事件所引起的中断。这些中断通常是同步发生的，也称为**异常（Exception）**。
    - **特点**：是CPU执行指令过程中检测到的，是CPU主动发现的。通常情况下，异常处理完成后会返回到发生异常指令的下一条指令或重新执行发生异常的指令。
    - **常见类型**：
        - **陷阱 (Trap)**：也称**陷入**，是一种有意的异常。通常由用户程序执行**系统调用指令**引起，目的是让用户程序从用户态陷入核心态，请求操作系统提供服务。例如，`read()`、`write()`等系统调用。陷阱处理完成后，通常返回到陷阱指令的下一条指令继续执行。
        - **故障 (Fault)**：一种可能被**修正**的异常。当CPU执行一条指令时，发现该指令无法继续执行，但可以通过某种方式修复后重新执行该指令。例如，**缺页故障（Page Fault）**，当程序访问的页面不在内存时产生，操作系统会将其从外存调入内存，然后重新执行引发故障的指令。
        - **终止 (Abort)**：一种**不可恢复**的严重错误。通常是硬件故障或严重的软件错误导致，程序无法继续执行。例如，除数为零、非法指令、栈溢出、硬件故障等。终止处理完成后，通常会终止导致错误的程序，甚至导致系统崩溃。



---


### 中断处理过程的步骤：保护现场、中断服务、恢复现场是核心

#### 详细讲解：
一个完整的中断处理过程通常包括以下几个核心步骤：

1. **中断请求（Interrupt Request, IRQ）**：
    - **原理**：当外部设备或CPU内部事件发生时，通过中断控制器向CPU发送中断信号。
2. **中断响应（Interrupt Acknowledge, INTA）**：
    - **原理**：CPU在每个指令执行周期结束时，会检查是否有中断请求。如果存在且中断被允许，CPU会响应中断，暂停当前程序的执行。
3. **保护现场（Save Context）**：
    - **原理**：这是中断处理的第一步，也是至关重要的一步。CPU需要将当前正在执行程序的**上下文信息**保存起来，以便中断处理完成后能够正确恢复被中断程序的执行。
    - **内容**：主要包括：
        - **程序计数器（PC）**：保存被中断指令的下一条指令地址。
        - **程序状态字（PSW）**：保存CPU的当前状态，如条件码、中断允许/禁止标志、运行模式（用户/核心态）等。
        - **通用寄存器（General Purpose Registers）**：保存程序使用的工作寄存器的内容。
    - **保存位置**：这些信息通常被压入**核心态栈（中断栈）**中。
4. **中断向量寻址**：
    - **原理**：CPU通过中断向量，查询**中断向量表（Interrupt Vector Table）**，获取对应中断服务程序的入口地址。
5. **执行中断服务程序（Interrupt Service Routine, ISR）**：
    - **原理**：CPU跳转到中断服务程序的入口地址，开始执行该程序。中断服务程序负责处理具体的中断事件，如I/O数据传输、更新系统时间、处理错误等。
    - **特点**：中断服务程序通常在**核心态**下执行，具有更高的权限。
6. **恢复现场（Restore Context）**：
    - **原理**：中断服务程序执行完毕后，需要将之前保存的被中断程序的上下文信息从栈中恢复到CPU的相应寄存器中。
    - **内容**：恢复PC、PSW、通用寄存器等。
7. **中断返回（Interrupt Return, IRET）**：
    - **原理**：通常通过一条特殊的机器指令（如`IRET`、`RETI`等）完成。这条指令会从栈中弹出PSW、PC等信息，使CPU回到被中断时的状态，并继续执行被中断的程序。


#### 常考点分析与陷阱：
- **保护现场的重要性**：这是实现中断的关键，确保程序执行的**连续性**和**透明性**（对于用户程序来说，中断是不可见的）。
- **核心态栈**：上下文信息通常保存在核心态栈中，而不是用户态栈，以防止用户程序恶意篡改。
- **关中断/开中断时机**：在保护现场和恢复现场期间，通常需要关中断，以保证操作的原子性。但在中断服务程序内部，如果允许更高优先级中断嵌套，则可以适时开中断。
- **异常与中断处理的异同**：异常处理与中断处理流程相似，但异常是同步的（由当前指令引起），且处理完成后可能需要重新执行引起异常的指令。

---


### 中断向量表的概念和作用

#### 详细讲解：
- **概念**： **中断向量表（Interrupt Vector Table, IVT）是内存中的一个特殊区域，它存储了系统中所有中断服务程序的入口地址（或称中断向量）**。每一个中断类型都对应表中的一个唯一入口。
    - 在早期的Intel X86架构中，中断向量表直接存储中断服务程序的入口地址。在现代操作系统中，中断向量表通常存储的是指向中断描述符（Interrupt Descriptor）的指针，这些描述符包含了更详细的信息，如中断服务程序的入口地址、运行权限等。
- **作用**： 中断向量表是实现**中断分发（Interrupt Dispatching）**的关键机制。它的主要作用是：
    1. **快速定位中断服务程序**：当CPU接收到中断信号并确认中断类型后，它会根据中断类型号（通常由中断控制器提供）作为索引，直接在中断向量表中查找对应的中断服务程序的起始地址，从而快速跳转到正确的处理程序。
    2. **实现中断的透明性**：对于CPU而言，它只需要知道中断类型号，就可以通过中断向量表找到对应的处理程序，而无需关心中断服务程序具体位于内存的哪个位置。
    3. **支持不同中断源的独立处理**：每种中断类型都有自己独立的中断服务程序，互不干扰，提高了系统的模块化和可维护性。
    4. **提供统一的入口**：所有中断都通过查询中断向量表这一统一机制来找到对应的处理程序。


#### 示例：
假设一个简化的中断向量表：

|   |   |   |
|---|---|---|
|**中断类型号**|**对应的中断服务程序入口地址**|**描述**|
|0x00|0x0000_1000|除零错误处理程序|
|0x01|0x0000_1100|单步执行中断|
|...|...|...|
|0x20|0x0000_2000|时钟中断处理程序|
|0x21|0x0000_2100|键盘中断处理程序|
|0x80|0x0000_8000|系统调用入口（Linux）|
|...|...|...|

当CPU接收到一个中断类型号为 `0x21` 的中断（键盘中断）时，它会查阅中断向量表，找到地址 `0x0000_2100`，然后跳转到该地址执行键盘中断服务程序。


#### 常考点分析：
- 中断向量表是操作系统初始化时建立的。
- 中断类型号（中断向量）是中断向量表的索引。
- 与**中断控制器**配合使用，中断控制器负责接收硬件中断请求并提供中断类型号给CPU。

---


### 中断与轮询（查询）的区别和优缺点
这是计算机系统设计中两种截然不同的I/O控制方式。

#### 详细讲解：
1. **轮询（Polling / Programmed I/O）**：
    
    - **原理**：CPU主动、周期性地检测I/O设备的状态寄存器，查看设备是否完成I/O操作或是否准备好进行数据传输。如果设备未准备好，CPU会一直重复查询，直到设备就绪。
    - **优点**：
        - **实现简单**：不需要复杂的中断硬件和中断处理机制。
        - **实时性高（对于简单系统）**：如果查询频率足够高，设备状态变化能立即被CPU检测到。
    - **缺点**：
        - **CPU利用率低**：CPU大部分时间浪费在等待I/O设备上，处于“忙等”状态，无法执行其他有意义的任务。
        - **不适用于多任务系统**：在多任务环境下，如果一个进程进行I/O操作采用轮询，会导致整个系统效率低下。
        - **响应时间不确定**：取决于轮询的周期，周期越长响应越慢。
        - **无法处理突发事件**：如果查询周期长，突发事件可能无法及时响应。
    - **适用场景**：简单、实时性要求不高、I/O设备速度快于CPU的场景（极少）。
2. **中断（Interrupt Driven I/O）**：
    
    - **原理**：CPU不主动查询设备状态。当I/O设备完成操作或需要CPU服务时，它会主动向CPU发送中断信号，CPU响应中断并处理。
    - **优点**：
        - **CPU利用率高**：CPU在等待I/O设备时可以执行其他任务，直到被中断信号唤醒。
        - **响应速度快**：设备一旦准备好，便立即通知CPU，响应及时。
        - **支持多任务系统**：中断是实现并发和多道程序设计的基石。
        - **能够处理突发事件**：I/O设备有事件发生即可触发中断，及时处理。
    - **缺点**：
        - **实现复杂**：需要额外的中断硬件（中断控制器）和复杂的中断处理软件（中断服务程序）。
        - **系统开销**：中断处理本身会引入上下文切换等开销。
    - **适用场景**：几乎所有现代多任务操作系统和对性能、响应性有要求的系统。


#### 比较表格：
|   |   |   |
|---|---|---|
|**特性**|**轮询（查询）**|**中断**|
|**CPU状态**|忙等，主动查询|空闲（等待I/O），被动响应|
|**CPU利用率**|低|高|
|**I/O控制**|CPU控制I/O|I/O设备控制CPU|
|**复杂性**|简单|复杂|
|**实时性**|周期性查询，可能不及时|及时响应|
|**并发性**|难以实现|实现并发的基础|
|**系统开销**|忙等本身开销大，但无需中断机制开销|上下文切换有开销，但CPU利用率高|


#### 常考点分析：
- **中断的本质是“事件驱动”**，轮询的本质是“状态驱动”。
- 中断是现代操作系统I/O管理的核心方式。
- 简答题常考两者的优缺点比较。

---


### 中断在I/O管理、进程调度、系统调用中的作用

#### 详细讲解：
1. **在I/O管理中的作用**：
    
    - **目的**：解决CPU与I/O设备速度不匹配的问题，提高CPU利用率。
    - **具体作用**：
        - **通知I/O完成**：当I/O设备完成数据传输后，会产生一个I/O中断，通知CPU。CPU接收中断后，中断服务程序会处理设备状态，将数据从缓冲区传输到用户内存，并唤醒等待该I/O的进程。
        - **错误处理**：I/O设备发生故障（如硬盘坏道、打印机缺纸）时，也会产生中断，操作系统通过中断服务程序进行错误处理。
        - **设备请求**：用户通过输入设备（如键盘、鼠标）进行操作时，设备会产生中断，操作系统通过中断服务程序响应用户请求。
    - **原理**：CPU发出I/O命令后，无需等待设备完成，可以立即切换到其他进程执行。I/O设备独立工作，完成后通过中断通知CPU，避免了CPU的忙等。
2. **在进程调度中的作用**：
    
    - **目的**：实现多道程序的并发执行和CPU的公平分配。
    - **具体作用**：
        - **时间片轮转调度**：**时钟中断**是实现时间片轮转调度的核心。操作系统通过设置硬件定时器，使其周期性地产生时钟中断。时钟中断服务程序会检查当前运行进程的时间片是否用完，如果用完，则触发进程调度器，进行进程切换，将CPU分配给下一个就绪进程。
        - **进程状态转换**：当一个进程执行I/O操作时，会等待I/O完成，此时它会主动放弃CPU，进入**等待态**。I/O完成后，对应的I/O中断服务程序会唤醒该进程，使其进入**就绪态**，等待调度。
        - **优先级调度**：高优先级事件（如紧急中断）可以抢占低优先级进程的执行。
    - **原理**：中断使操作系统能够周期性地或在特定事件发生时**强制夺回CPU的控制权**，从而实现对进程的有效管理和调度。
3. **在系统调用中的作用**：
    
    - **目的**：为用户程序提供访问操作系统核心功能的接口，同时保护操作系统内核不受用户程序破坏。
    - **具体作用**：
        - **模式切换**：用户程序无法直接访问硬件或执行特权指令。当用户程序需要操作系统服务时（如创建文件、分配内存），它会执行一条特殊的**陷阱指令（软中断指令）**。这条指令会产生一个内中断，导致CPU从**用户态**切换到**核心态**。
        - **服务调用**：中断服务程序根据系统调用号，跳转到操作系统内核中对应的系统服务例程执行，完成用户请求。
        - **隔离与保护**：通过中断机制，操作系统对用户程序的访问权限进行严格限制，只有通过系统调用这一“受控入口”，用户程序才能访问内核功能，保证了系统的安全性和稳定性。
    - **原理**：系统调用是用户程序主动请求的服务，通过制造一个**内中断（陷阱）**来实现从用户态到核心态的转换，从而执行特权操作。


#### 常考点分析：
- 中断是操作系统**从用户态切换到核心态**的主要方式之一（另一种是异常）。
- 区分“I/O中断”和“系统调用中断”：I/O中断是被动发生的（硬件引起），系统调用中断是主动发生的（软件指令引起）。

---


### 中断优先级和多重中断的概念

#### 详细讲解：
1. **中断优先级 (Interrupt Priority)**：
    
    - **概念**：当系统中存在多个中断源同时请求CPU服务时，CPU需要确定优先响应哪个中断。中断优先级就是用来解决这种冲突的机制。每个中断源被赋予一个优先级，通常由**中断控制器**管理。
    - **优先级原则**：
        - **硬件故障 > 软件中断（异常、陷阱） > I/O中断 > 时钟中断**
        - 一般来说，越紧急、越需要及时处理的事件，优先级越高。例如，电源故障中断通常是最高优先级。
    - **作用**：确保重要或紧急的中断事件能够被及时响应和处理。
2. **多重中断 (Multiple Interrupts / Interrupt Nesting)**：
    
    - **概念**：指在一个中断服务程序（ISR）正在执行期间，又发生了另一个中断请求。如果新发生的中断请求的优先级**高于**当前正在执行的ISR的优先级，且CPU允许中断嵌套，则CPU会暂停当前ISR的执行，转而去响应并处理新的高优先级中断。这就是**中断嵌套**。
    - **处理过程**：
        1. 当前ISR执行中。
        2. 发生更高优先级中断请求。
        3. CPU响应新的高优先级中断。
        4. **保存当前ISR的现场**（包括PC、PSW和可能正在使用的寄存器），通常压入栈中。
        5. 跳转执行高优先级中断的服务程序。
        6. 高优先级中断服务程序执行完毕。
        7. 恢复之前被中断的低优先级ISR的现场。
        8. 低优先级ISR继续执行。
    - **实现机制**：通过**硬件中断控制器**和**CPU的状态寄存器（PSW中的中断允许/禁止位）**来实现。中断控制器会根据优先级决定是否向CPU发送中断信号，CPU通过PSW中的中断允许位来控制是否响应新的中断。
    - **重要性**：多重中断机制使得系统能够高效地处理多个并发发生的事件，保证了高优先级任务的实时性。


#### 图示 (多重中断)：
代码段

```
graph TD
    A[CPU执行用户程序P] --> B{发生中断A (低优先级)};
    B --> C[保护P现场，转入中断A ISR];
    C --> D[中断A ISR执行...];
    D --> E{中断A ISR执行期间，发生中断B (高优先级)};
    E -- Yes --> F[保护中断A ISR现场，转入中断B ISR];
    F --> G[中断B ISR执行...];
    G --> H[中断B ISR执行完毕];
    H --> I[恢复中断A ISR现场];
    I --> J[中断A ISR继续执行...];
    J --> K[中断A ISR执行完毕];
    K --> L[恢复用户程序P现场];
    L --> M[用户程序P继续执行];
```


#### 常考点分析与陷阱：
- **区别**：中断优先级解决的是“先处理哪个中断”的问题；多重中断解决的是“当前中断处理过程中能否响应新中断”的问题。
- **嵌套条件**：只有当新中断的优先级**高于**当前正在执行的中断优先级，并且CPU**允许中断嵌套（开中断）**时，才会发生多重中断。
- **上下文保存**：在多重中断中，每次发生中断嵌套时，都会**额外保存一次当前被中断的上下文**。
- **关中断的作用**：在处理非常关键、不允许被打断的代码段（如保护现场和恢复现场），会暂时关闭中断，以确保原子性操作。但如果关中断时间过长，可能导致高优先级中断得不到及时响应。

---


#### 命题方式：
1. **选择题**：
    
    - **考察点**：中断的分类（内外中断、异常/陷阱/故障的辨析）、中断处理步骤的顺序和作用（尤其是保护/恢复现场的内容）、中断向量表的概念、中断与CPU利用率/I/O控制方式的对比、中断优先级和多重中断的定义。
    - **陷阱**：
        - 混淆**异常、陷阱、故障**的具体含义和触发机制。例如，“除数为零”是故障，不是陷阱。
        - 混淆**中断和系统调用**的关系：系统调用通过陷阱（软中断）实现，本质是用户程序主动请求服务，而非硬件设备触发的外部中断。
        - 对**上下文保存的内容**理解不全：不只是PC，还有PSW、通用寄存器等。
        - 对**中断返回指令**的理解：不仅仅是返回PC，还包括恢复PSW等。
2. **简答题/分析题**：
    
    - **考察点**：结合具体场景（如I/O操作、时间片轮转调度、系统调用过程），分析中断在其中扮演的角色和作用。详细比较中断与轮询的优缺点。解释中断处理过程各个步骤的意义和重要性。解释多重中断的发生条件和处理过程。
    - **陷阱**：
        - **描述不严谨**：例如，在解释中断处理过程时，未提及“关中断/开中断”的时机和必要性，或未说明上下文保存到核心态栈。
        - **对原理理解不深**：在比较中断和轮询时，未能从“CPU利用率”“并发性”等核心角度深入分析。
        - **缺乏系统性**：在分析中断在操作系统中作用时，未能从I/O管理、进程调度、系统调用等多个维度进行全面阐述。
3. **概念辨析题**：
    
    - **考察点**：区分**中断**和**异常**（中断是异步的，异常是同步的）；区分**陷阱**和**故障**（陷阱是有意的，故障是可修复的错误）；区分**中断**和**程序查询（轮询）**。
    - **陷阱**：
        - **死记硬背概念，缺乏深入理解**：例如，虽然知道陷阱是系统调用，但不能解释为什么系统调用要通过陷阱实现（模式切换和保护）。
        - **未能抓住本质区别**：例如，中断是“被动发生”，异常是“主动检测到”或“主动请求”。


#### 备考建议：
- **理解核心概念**：不要死记硬背，要理解中断为什么会产生，它解决了什么问题，以及它是如何工作的。
- **画图辅助理解**：流程图是理解中断处理过程、系统调用过程的有效工具。
- **多做真题**：通过分析历年真题，掌握不同题型的命题规律和常考陷阱。
- **注重细节和边界情况**：例如，中断优先级、多重中断、关中断/开中断的时机等，这些往往是区分高分和一般分数的关键点。

---



## 中断上下文的保存与中断向量的产生时机

### 上下文保存：硬件与操作系统的分工
在中断处理过程中，为了保证被中断的程序能够无缝地恢复执行，需要保存其执行现场，即**上下文**。这个保存过程是**硬件和操作系统（软件）协同完成**的。

#### 详细讲解：
1. 由硬件自动保存的上下文：
    
    当CPU检测到中断并响应时，在真正跳转到中断服务程序之前，为了快速、高效地处理中断，CPU硬件会自动执行一些必要的状态保存操作。这些操作通常是不可屏蔽的，且是CPU微指令级别的。
    
    - **程序计数器（Program Counter, PC / Instruction Pointer, IP）**：指向被中断指令的下一条指令地址。这是最核心的保存内容，以便中断处理完成后能回到正确的执行点。
    - **程序状态字（Program Status Word, PSW / EFLAGS 寄存器）**：包含CPU的当前状态信息，如条件码（零标志、进位标志等）、中断允许/禁止标志（IF位）、CPU的运行模式（特权级/CPL）等。保存这些是为了恢复CPU在被中断时的完整运行环境。
    - **栈指针（Stack Pointer, SP / ESP 寄存器）**：通常，这些硬件保存的信息会被压入到**核心态栈（或特权栈）**中。因此，当前用户栈的栈指针可能也会在这一阶段被硬件自动压栈。
    - **模式切换信息**：如果是从用户态切换到核心态，硬件还会处理特权级的切换，并可能压入一些与特权级切换相关的段寄存器信息。
    
    **总结**：硬件主要保存那些对CPU执行流和状态至关重要的、且必须立即保存的信息，这些信息是CPU响应中断后最直接需要处理的。这些操作发生在中断服务程序执行之前，且通常由CPU内部的微代码或专用电路完成。
    
2. 由操作系统（软件）保存的上下文：
    
    在硬件完成初步的上下文保存并跳转到中断服务程序之后，操作系统会接管控制权。此时，操作系统根据中断类型和实际需要，通过软件指令进一步保存其他必要的上下文信息。
    
    - **通用寄存器（General Purpose Registers）**：硬件通常不会自动保存所有通用寄存器。中断服务程序（操作系统代码）在开始执行其逻辑之前，会主动将所有可能被其修改的通用寄存器内容保存起来。这是因为中断服务程序也需要使用这些寄存器进行计算，为了不污染被中断程序的寄存器状态，必须先保存。
    - **浮点寄存器、向量寄存器等特殊寄存器**：如果被中断的程序使用了浮点运算单元或其他扩展指令集（如SIMD），那么相应的浮点寄存器、向量寄存器等也需要由操作系统保存。这通常发生在进程切换或一些复杂中断处理中，而不是所有中断都必须保存。
    - **其他进程相关的状态信息**：例如，被中断进程的内存管理信息（页表基址寄存器，如果需要切换页表）、调度相关信息（如时间片剩余量）、I/O状态信息等，这些都由操作系统在**进程控制块（PCB）**中维护和管理，并在必要时进行更新。
    
    **总结**：操作系统主要保存那些硬件未自动保存但对进程恢复执行或后续调度至关重要，以及在中断服务程序执行过程中可能被修改的寄存器内容。这些操作由**中断服务程序（一段软件代码）**完成。


#### 易错点：
- **所有寄存器都由硬件保存**：这是错误的。硬件通常只保存少数核心寄存器，而大部分通用寄存器由操作系统通过软件指令保存。
- **上下文保存的栈**：始终是**核心态栈**，而不是用户态栈，这是为了防止用户程序的非法访问和篡改，保证内核的安全。

---


“中断向量是什么时候产生的”这个问题，可以从两个层面来理解：

1. **中断向量表的构建时机**：即存储中断向量的这张表是什么时候创建和初始化的。
2. **中断向量（类型号）的获取时机**：即CPU在响应中断时，如何知道是哪个中断类型，从而获得对应的中断向量（号）。


#### 详细讲解：
1. 中断向量表的构建时机：
    
    中断向量表是在操作系统启动（引导）时，由操作系统内核进行初始化和构建的。
    
    - 在系统引导阶段，操作系统会将预先定义好的各个中断服务程序的入口地址（或指向中断描述符的指针）填充到内存中的指定位置，形成中断向量表。
    - 这个过程通常发生在操作系统加载并初始化其核心数据结构时。例如，Linux内核在启动时会设置中断描述符表（IDT），并为每个中断号（中断向量）关联一个中断处理函数。
    - 一旦中断向量表被构建完成，其内容在系统运行期间是相对稳定的，除非系统需要动态加载或卸载某些设备驱动，或者进行热插拔操作，可能会对部分中断向量进行更新。
2. 中断向量（类型号）的获取时机：
    
    当硬件产生中断请求并被CPU响应时，CPU会从硬件（通常是中断控制器）那里获取中断向量（即中断类型号）。
    
    - **外部中断（如I/O中断、时钟中断）**：
        - 当I/O设备或定时器产生中断请求时，它会将中断信号发送给**中断控制器**（如8259A可编程中断控制器）。
        - 中断控制器负责管理多个中断源的请求，并根据优先级仲裁。
        - 当CPU准备响应中断时，它会向中断控制器发送一个**中断应答信号**（INTA），中断控制器在接收到此信号后，会将对应中断源的**中断类型号（中断向量号）**放到数据总线上，供CPU读取。
        - CPU获取到这个中断类型号后，就以它为索引去中断向量表（或IDT）中查找对应的中断服务程序入口地址。
    - **内中断（异常、陷阱）**：
        - 内中断是CPU在执行指令过程中检测到的，因此**中断类型号直接由CPU自身产生**。例如，执行`INT n`指令（陷阱）时，`n`就是中断类型号；发生除零错误时，CPU硬件会生成一个预定义的除零异常的中断类型号。
        - CPU在检测到这些内部事件后，会直接使用相应的内部定义的中断类型号进行中断向量表的寻址。


#### 常考点分析：
- **中断向量表是操作系统软件构建的**，存储在内存中。
- **中断向量（类型号）的获取**：
    - **外部中断**：由**中断控制器**提供给CPU。
    - **内中断**：由**CPU自身**根据异常类型产生。
- 中断向量是中断服务程序的**唯一标识**，使得CPU能够快速定位到正确的处理程序。
