---
{"dg-publish":true,"dg-permalink":"/408/IO的独立编址与统一编址,状态&控制寄存器","permalink":"/408/IO的独立编址与统一编址,状态&控制寄存器/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

## 图片解释与实现逻辑
图片展示了两种打印机模型，分别代表了两种不同的 I/O 编址方式和相应的 I/O 操作逻辑：
![Pasted image 20250701192528.png](/img/user/%E9%99%84%E4%BB%B6/Pasted%20image%2020250701192528.png)
### 打印机型号 1：统一编址方式（内存映射 I/O，Memory-Mapped I/O）
- **特点**：I/O 设备被视为内存的一部分，与内存共享同一套地址空间。CPU 访问 I/O 设备的方式与访问内存单元的方式相同，即使用普通的访存指令（如 `MOV` 指令）。
    
- **I/O 端口与地址**：
    
    - **数据缓冲寄存器**：地址为 `0xffff2021`。这是一个内存地址，CPU 可以直接向这个地址写入数据，这些数据就会被送到打印机的数据缓冲器。
        
    - **控制/状态寄存器**：地址为 `0xffffe0f1`。这也是一个内存地址，CPU 通过读写这个地址来获取打印机状态或发送控制命令。
        
- **`print` 函数逻辑 (`print(char s[16])`)**：
    
    1. `F5H->addr(0xffff2021)`: 这行代码表示将十六进制值 `F5H` 写入到地址 `0xffff2021`。根据下方的“命令字”表格，`F5H` 对应的行为是“**将假定内容写入数据缓冲寄存器**”。这里的 `F5H` 实际上是伪代码中用于表示“要打印的数据”或“一个数据字节”。
        
    2. `F6H->addr(0xffffe0f1)`: 这行代码表示将十六进制值 `F6H` 写入到地址 `0xffffe0f1`。根据下方的“命令字”表格，`F6H` 对应的行为是“**打印数据缓冲寄存器中的值**”。这意味着 CPU 通过向控制寄存器写入 `F6H` 命令，触发打印机开始打印其数据缓冲器中的内容。
        
- print 函数的整体逻辑：
    
    伪代码 print(char s[16]) 意图是打印一个16字节的字符串 s。
    
    - 将待打印的第一个字符 `s[0]` 写入数据缓冲寄存器 `0xffff2021`。
        
    - 向控制/状态寄存器 `0xffffe0f1` 写入 `F6H` 命令，启动打印。
        
    - 这个过程会循环16次，每次写入一个字符并启动打印。
        
    - **缺陷**：这种伪代码简化了实际的I/O控制过程。在实际中，CPU写入数据后，通常需要查询状态寄存器以确认设备是否准备好接收下一个数据字节，或者是否打印完成，而不是简单地连续写入和触发。如果 `F6H` 命令是让打印机打印一个字节，那么每一次 `F5H` 和 `F6H` 的组合就是传输一个字节并启动打印。


### 打印机型号 2：独立编址方式（I/O 端口编址，Port-Mapped I/O）
- **特点**：I/O 设备有自己独立的地址空间，与内存地址空间是分开的。CPU 访问 I/O 设备需要使用专门的 I/O 指令（如 `IN` 和 `OUT` 指令）。
    
- **I/O 端口与地址**：
    
    - **数据缓冲寄存器**：端口号 `20H`。CPU 需要使用 `OUT 20H, data` 这样的指令将数据写入该端口。
        
    - **控制/状态寄存器**：端口号 `21H`。CPU 需要使用 `OUT 21H, command` 这样的指令向该端口发送命令。
        
- **`print` 函数逻辑 (`print(char s[16])`)**：
    
    1. `F5H in 20H, 20H`：这行伪代码表示将 `F5H`（假定内容）写入到端口号为 `20H` 的数据缓冲寄存器。这里的 `20H` 表示端口地址。
        
    2. `EEH in 21H, 21H`：这行伪代码表示将 `EEH`（打印数据缓冲寄存器中的值）写入到端口号为 `21H` 的控制/状态寄存器。这里的 `21H` 表示端口地址。
        
- **`print` 函数的整体逻辑**：
    
    - 与打印机型号1类似，伪代码意图是打印一个16字节的字符串 `s`。
        
    - 每次将一个字符写入端口 `20H`。
        
    - 每次向端口 `21H` 发送 `EEH` 命令，启动打印。
        
    - **缺陷**：同样简化了实际的I/O控制过程，没有考虑状态查询和同步。
        

---



## I/O 过程中的数据流向

### 1. 从 CPU 到 I/O 端口（数据缓冲寄存器）
- **统一编址方式**：
    
    - **数据流向**：CPU -> 地址总线/数据总线 -> 内存地址译码器（或直接 I/O 地址译码器）识别为 I/O 设备地址 -> I/O 接口内部的数据缓冲寄存器。
        
    - **指令**：普通的内存写指令（如 `MOV [0xffff2021], AL`）。
        
- **独立编址方式**：
    
    - **数据流向**：CPU -> I/O 地址总线/数据总线（或复用总线但有特殊控制信号） -> I/O 端口译码器 -> I/O 接口内部的数据缓冲寄存器。
        
    - **指令**：专门的 I/O 写指令（如 `OUT 20H, AL`）。


### 2. 从 CPU 到 I/O 端口（控制/状态寄存器）
- **统一编址方式**：
    
    - **数据流向**：与写入数据缓冲寄存器类似，只是写入的是控制命令。CPU -> 地址总线/数据总线 -> I/O 接口内部的控制/状态寄存器。
        
    - **指令**：普通的内存写指令（如 `MOV [0xffffe0f1], F6H`）。
        
- **独立编址方式**：
    
    - **数据流向**：与写入数据缓冲寄存器类似，只是写入的是控制命令。CPU -> I/O 地址总线/数据总线 -> I/O 接口内部的控制/状态寄存器。
        
    - **指令**：专门的 I/O 写指令（如 `OUT 21H, EEH`）。


### 3. I/O 接口内部的数据流向（以打印为例）
- 数据写入**数据缓冲寄存器**后，就等待打印机处理。
    
- CPU 通过写入命令到**控制/状态寄存器**来驱动设备工作。例如，发送“打印”命令后，打印机接口会从其数据缓冲寄存器中取出数据，并通过打印机内部的机制（如打印头、墨水/碳粉等）将其呈现在纸张上。
    
- 打印机工作过程中，其状态（如忙、空闲、缺纸、墨尽等）会反映在**状态寄存器**中。CPU 可以通过读取状态寄存器来了解设备的工作状态，从而进行同步和错误处理。


### 4. 从 I/O 设备到 CPU（数据回流，如读取状态）
- **统一编址方式**：
    
    - **数据流向**：I/O 接口内部的状态/数据寄存器 -> 数据总线 -> CPU 寄存器或内存单元。
        
    - **指令**：普通的内存读指令（如 `MOV AL, [0xffffe0f1]`）。
        
- **独立编址方式**：
    
    - **数据流向**：I/O 接口内部的状态/数据寄存器 -> 数据总线 -> CPU 寄存器。
        
    - **指令**：专门的 I/O 读指令（如 `IN AL, 21H`）。
        

---

1. **I/O 编址方式**：这是最核心的考点。
    
    - **统一编址（内存映射 I/O）**：
        
        - **优点**：不需要专门的 I/O 指令，CPU 访问 I/O 端口和内存一样快，程序设计更灵活。
            
        - **缺点**：I/O 端口会占用一部分内存地址空间，限制了内存寻址范围；需要更复杂的 I/O 地址译码电路。
            
    - **独立编址（I/O 端口编址）**：
        
        - **优点**：I/O 地址空间独立，不占用内存地址空间；CPU 和 I/O 设备有明确的分离。
            
        - **缺点**：需要专门的 I/O 指令，且 I/O 指令通常比内存访存指令慢；编程不如统一编址灵活。
            
2. **数据流向**：考察对 CPU、总线、I/O 接口、设备之间数据传输路径的理解。
    
3. **设备控制方式**：图片中的伪代码体现了**程序查询方式**的简单逻辑（尽管简化了状态查询）。在实际考题中，会对比程序查询、中断、DMA 等方式的特点、优缺点及适用场景。
    
4. **寄存器作用**：数据缓冲寄存器（存放待传输数据）、控制寄存器（CPU 发送命令）、状态寄存器（CPU 读取设备状态）。
    
5. **指令类型**：区分统一编址下的访存指令和独立编址下的专用 I/O 指令。



## 状态寄存器状态存储与CPU查询示例

### 1. 状态寄存器的位定义
假设我们有一个简单的打印机接口，其**状态寄存器（Status Register）**是一个 8 位的寄存器。我们可以定义其中一些位的含义如下：

|位编号 (Bit)|含义|值 = 0 的意义|值 = 1 的意义|
|---|---|---|---|
|Bit 0|**忙/空闲状态 (BUSY)**|打印机空闲（Ready）|打印机忙（Busy）|
|Bit 1|**错误状态 (ERROR)**|无错误|发生错误|
|Bit 2|**缺纸状态 (PAPER_OUT)**|有纸|缺纸|
|Bit 3|**墨尽状态 (INK_LOW)**|墨水充足|墨水低或墨尽|
|...|(其他状态位)|||

**例如：**

- 如果状态寄存器的值为 `0000 0001` (二进制)，表示只有 Bit 0 为 1，即打印机处于**忙碌状态**。
    
- 如果状态寄存器的值为 `0000 0100` (二进制)，表示只有 Bit 2 为 1，即打印机**缺纸**。


### 2. CPU 查询状态寄存器的工作流程（伪代码示例）
假设我们使用**统一编址方式**（内存映射 I/O），并且打印机的状态寄存器地址是 `0xFFFFF000`。

```c
#define PRINTER_STATUS_REG_ADDR  0xFFFFF000 // 打印机状态寄存器的内存地址
#define PRINTER_DATA_REG_ADDR    0xFFFFF004 // 打印机数据寄存器的内存地址
#define PRINTER_CONTROL_REG_ADDR 0xFFFFF008 // 打印机控制寄存器的内存地址

// 状态寄存器位掩码 (用于判断特定状态位)
#define STATUS_BUSY_MASK     0x01 // Bit 0
#define STATUS_ERROR_MASK    0x02 // Bit 1
#define STATUS_PAPER_MASK    0x04 // Bit 2
#define STATUS_INK_MASK      0x08 // Bit 3
// ... 其他位定义

// 打印单个字符的函数 (采用程序查询方式)
void printChar(char c) {
    volatile unsigned char* status_reg = (volatile unsigned char*)PRINTER_STATUS_REG_ADDR;
    volatile unsigned char* data_reg = (volatile unsigned char*)PRINTER_DATA_REG_ADDR;
    volatile unsigned char* control_reg = (volatile unsigned char*)PRINTER_CONTROL_REG_ADDR;

    // 1. 等待打印机空闲
    while ((*status_reg & STATUS_BUSY_MASK) != 0) { // 循环检测BUSY位，直到它变为0
        // 打印机忙，CPU在这里空转等待
        // 可以在这里添加一些延时或简单的空操作
    }

    // 2. 检查是否有错误或其他异常状态
    if ((*status_reg & STATUS_ERROR_MASK) != 0) {
        // 检测到错误，进行错误处理（例如，打印错误信息，或者尝试重置打印机）
        printf("Error: Printer encountered an error!\n");
        // 这里可以添加更复杂的错误处理逻辑，例如，向控制寄存器写入重置命令
        return; // 或者退出
    }
    if ((*status_reg & STATUS_PAPER_MASK) != 0) {
        printf("Error: Printer is out of paper!\n");
        // 提示用户加纸，或者等待用户加纸
        return;
    }
    if ((*status_reg & STATUS_INK_MASK) != 0) {
        printf("Warning: Printer ink is low!\n");
        // 可以继续打印，但给出警告
    }

    // 3. 打印机空闲且无严重错误，写入数据
    *data_reg = c; // 将字符写入数据寄存器

    // 4. 发送打印命令 (假设向控制寄存器写入特定值启动打印)
    // 假设写入 0x01 表示启动打印当前数据
    *control_reg = 0x01; 

    // 5. 再次等待打印机空闲（直到这个字符被处理完成）
    while ((*status_reg & STATUS_BUSY_MASK) != 0) {
        // 等待当前字符打印完成
    }
}

// 打印字符串的函数
void printString(const char* str) {
    for (int i = 0; str[i] != '\0'; i++) {
        printChar(str[i]);
    }
}

// 主程序示例
int main() {
    // 模拟打印一些字符
    printString("Hello, 408!\n");
    printString("This is a test print.\n");

    return 0;
}
```


### 3. 工作原理和数据流向
1. **CPU 写入指令**：当程序要打印一个字符 `c` 时，CPU 执行 `printChar(c)` 函数。
    
2. **查询状态寄存器（数据回流到 CPU）**：
    
    - 首先，CPU 会执行一条**读内存指令**（在统一编址下），从地址 `0xFFFFF000` 读取打印机状态寄存器的内容。
        
    - 读取到的状态值会进入 CPU 的某个寄存器。
        
    - CPU 通过**逻辑运算**（例如 `&` 操作和比较），检查状态值中 `BUSY` 位是否为 1。
        
3. **循环等待 (程序查询)**：
    
    - 如果 `BUSY` 位为 1，表示打印机正忙，CPU 会陷入一个**忙等待（busy-waiting）**循环。它会不断地重复读取状态寄存器，直到 `BUSY` 位变为 0。
        
    - 在这个等待过程中，CPU 无法执行其他有用的任务，这是程序查询方式的主要缺点。
        
4. **状态判断与错误处理**：
    
    - 一旦打印机空闲，CPU 会进一步检查 `ERROR`、`PAPER_OUT`、`INK_LOW` 等位。
        
    - 如果某个错误位被设置（例如 `PAPER_OUT` 为 1），程序可以打印相应的错误消息，甚至暂停打印，提示用户处理。
        
5. **写入数据（CPU 到 I/O）**：
    
    - 如果一切正常，CPU 执行一条**写内存指令**，将要打印的字符 `c` 写入到打印机数据寄存器（地址 `0xFFFFF004`）。
        
6. **发送控制命令（CPU 到 I/O）**：
    
    - 接着，CPU 执行一条**写内存指令**，将启动打印的命令（`0x01`）写入到打印机控制寄存器（地址 `0xFFFFF008`）。
        
    - 打印机接口接收到命令后，会将 `BUSY` 位设置为 1，开始处理数据并进行打印。
        
7. **循环等待下一个空闲**：CPU 再次进入忙等待循环，等待 `BUSY` 位变为 0，表示当前字符已打印完成，可以继续处理下一个字符或任务。



## 状态寄存器和控制寄存器是融为一体的吗？
**通常情况下，状态寄存器和控制寄存器是分开的两个逻辑实体，但它们可以被设计在同一个 I/O 接口芯片中，甚至可以共享同一个物理地址或端口，通过读写操作来区分其功能。**

- **逻辑上**：它们是两个不同的功能模块。
    
    - **状态寄存器 (Status Register)**：主要由 I/O 设备或接口**写入**，CPU **读取**，用于反映设备当前的状态信息。
        
    - **控制寄存器 (Control Register)**：主要由 CPU **写入**，I/O 设备或接口**读取**，用于接收 CPU 的控制命令。
        
- **物理实现上**：
    
    - **独立地址/端口**：最常见的设计是，它们拥有各自独立的内存地址或 I/O 端口。例如，打印机的数据缓冲寄存器可能在 `20H`，状态寄存器在 `21H`，控制寄存器在 `22H`。
        
    - **共享地址/端口，读写分离**：有些设计为了节省地址空间，会将状态寄存器和控制寄存器映射到同一个物理地址或端口。在这种情况下：
        
        - 当 CPU **读取**该地址/端口时，读到的是**状态信息**（状态寄存器）。
            
        - 当 CPU 写入该地址/端口时，写入的是控制命令（控制寄存器）。
            
            这种设计需要 I/O 接口内部的硬件电路来区分读写操作，将数据路由到正确的内部寄存器。
            
    - **部分功能融合**：在某些简单的接口中，少数状态位和控制位可能在同一个寄存器中，但各自负责不同的功能。但这并不代表它们完全融合，只是对资源的复用。
        

**结论**：可以说它们是**逻辑分离，但可能在物理实现上相邻、相关联，甚至共享地址/端口但功能互补**。

---



## 状态寄存器和控制寄存器的内部结构
状态寄存器和控制寄存器都是由一系列**二进制位（bit）**组成的寄存器。每个位或几个位组合起来代表一个特定的状态信息或控制命令。

### 1. 状态寄存器 (Status Register) 的内部结构
状态寄存器是一个用于**反映设备当前工作状态**的位集合。每个位通常代表一个布尔型的状态信息（真/假，有/无）。

|位编号 (Bit)|含义|值 = 0 的意义|值 = 1 的意义|举例说明（打印机）|
|---|---|---|---|---|
|Bit 0|**忙/空闲 (BUSY)**|设备空闲（Ready）|设备忙碌（Busy）|CPU 写入数据或命令后，设备将此位设为 1，完成后设为 0。|
|Bit 1|**数据就绪 (DRDY)**|数据寄存器无有效数据|数据寄存器有新数据可读|设备完成一次数据读取/转换后，设为 1，CPU 读取后设为 0。|
|Bit 2|**错误 (ERROR)**|无错误|发生错误|设备检测到故障时设为 1，CPU 可读取以进行错误处理。|
|Bit 3|**缺纸 (PAPER_OUT)**|纸张正常|纸张不足或用尽|打印机纸仓状态传感器检测到缺纸时设为 1。|
|Bit 4|**墨尽 (INK_LOW)**|墨水充足|墨水不足或用尽|墨盒传感器检测到墨量低时设为 1。|
|Bit 5|**完成 (DONE)**|未完成当前操作|当前操作已完成|设备完成一个任务（如打印一页）后设为 1。|
|Bit 6|**中断请求 (IRQ)**|无中断请求|正在请求中断|设备需要 CPU 服务时，将此位设为 1。|
|...|(其他状态位)||||


### 2. 控制寄存器 (Control Register) 的内部结构
控制寄存器是一个用于**向设备发送命令和配置其工作模式**的位集合。CPU 通过设置这些位来改变设备的行为。

|位编号 (Bit)|含义|值 = 0 的意义|值 = 1 的意义|举例说明（打印机）|
|---|---|---|---|---|
|Bit 0|**启动/停止 (START)**|停止操作|启动操作|CPU 写入 1 启动打印，写入 0 停止。|
|Bit 1|**中断使能 (INT_EN)**|禁用中断|使能中断|CPU 写入 1 允许设备在完成时产生中断，写入 0 禁用。|
|Bit 2|**复位 (RESET)**|正常工作|复位设备|CPU 写入 1 来重置设备到初始状态。|
|Bit 3|**打印模式 (MODE1)**|(例如) 普通模式|(例如) 草稿模式|CPU 通过设置这些位来选择打印质量、单双面等。|
|Bit 4|**打印模式 (MODE2)**|(例如) 文本模式|(例如) 图片模式||
|Bit 5|**数据传输方向 (DIR)**|(例如) 输入方向|(例如) 输出方向|用于双向传输设备，CPU 可控制数据流向。|
|...|(其他控制位)||||

---


### 表格来展示其结构示例
以下表格展示了一个假设的 I/O 接口中，状态寄存器和控制寄存器的**位级结构**：

#### 示例 1：状态寄存器 (8 位)
|位编号 (Bit)|7|6|5|4|3|2|1|0|
|---|---|---|---|---|---|---|---|---|
|**功能**|未用|**IRQ**|**完成**|**墨尽**|**缺纸**|**错误**|**数据就绪**|**忙/空闲**|
|**读写属性**|只读|只读|只读|只读|只读|只读|只读|只读|

- **解释**：CPU 读取整个 8 位寄存器的值，然后通过位掩码和逻辑与操作来判断各个位的状态。例如，`status & 0x01` 检查忙/空闲位。


#### 示例 2：控制寄存器 (8 位)
|位编号 (Bit)|7|6|5|4|3|2|1|0|
|---|---|---|---|---|---|---|---|---|
|**功能**|未用|未用|**传输方向**|**打印模式2**|**打印模式1**|**复位**|**中断使能**|**启动/停止**|
|**读写属性**|只写|只写|只写|只写|只写|只写|只写|只写|

- **解释**：CPU 写入整个 8 位寄存器的值，通过设置不同的位组合来发送命令或配置设备。例如，写入 `0x01` 启动设备，写入 `0x04` 复位设备。


### 注意：
- 这些位定义是**接口设计者约定**的，不同设备和接口会有不同的位定义。
    
- 某些位可能是**读/写**的（例如，可以读取当前配置，也可以写入新配置）。
    
- 在实际中，为了提供更丰富的状态和更复杂的控制，寄存器可能会有 16 位、32 位甚至更多。
    
- **共享地址的情况**：如果状态寄存器和控制寄存器共享一个物理地址 `0xABCD`：
    
    - `result = READ(0xABCD)`：这将从**状态寄存器**读取值。
        
    - `WRITE(0xABCD, command_value)`：这将把 `command_value` 写入**控制寄存器**。
        

---



## 详细解释：映射到同一个端口的机制
当状态寄存器和控制寄存器共享同一个 I/O 端口地址或内存映射地址时，其内部机制如下：

1. **物理实现**：
    
    - 在 I/O 接口内部，实际上仍然存在两个独立的硬件寄存器：一个用于存储**状态信息**（状态寄存器），另一个用于存储**控制命令**（控制寄存器）。它们是独立的存储单元，其内容是各自独立的，互不影响。
        
    - 它们被设计成**响应同一个外部地址线和数据线的组合**。
        
2. **读写操作的区分**：
    
    - **CPU 的控制信号**：CPU 在执行 I/O 操作时，除了将地址放到地址总线上，还会发出**读控制信号**（如 `MEMR#` 或 `IOR#`）或**写控制信号**（如 `MEMW#` 或 `IOW#`）。
        
    - **I/O 接口内部的逻辑电路**：I/O 接口的地址译码电路在识别到匹配的地址后，还会同时检测 CPU 发出的读写控制信号。
        
        - 如果检测到是**读操作信号**：那么 I/O 接口会将**状态寄存器**中的当前内容放到数据总线上，供 CPU 读取。此时，控制寄存器不会被访问。
            
        - 如果检测到是**写操作信号**：那么 I/O 接口会将数据总线上的内容（CPU 要写入的命令）写入到**控制寄存器**中。此时，状态寄存器不会被修改。

### 示例图示（逻辑示意图）
```
+-------------------------------------------------------------+
|                       CPU                                   |
|                                                             |
|   地址总线 (I/O Port Address)                               |
|   数据总线 (Data)                                           |
|   读控制信号 (Read Signal) ---->                            |
|   写控制信号 (Write Signal) ---->                           |
+-------------------------------------------------------------+
               |     |     |     |
               |     |     |     |
               V     V     V     V
+-------------------------------------------------------------+
|                   I/O 接口芯片                              |
|                                                             |
| +-------------------------+   +-------------------------+   |
| |                         |   |                         |   |
| | **地址译码电路** |   | **读写控制逻辑** |   |
| | (识别共享端口地址 21H)  |   | (根据读写信号决定路由)  |   |
| |                         |   |                         |   |
| +----------|--------------+   +---------|---------------+   |
|            |                          |                    |
|            |                          V                    |
|            |                  +---------------------+      |
|            |                  |                     |      |
|            +----------------->| **数据通路多路选择器**|      |
|                               | (Mux / Demux)       |      |
|                               |                     |      |
|                               +----------|----------+      |
|                                          |                 |
|                     +--------------------+--------------------+
|                     |                    |                    |
|                     V                    V                    |
|             +-----------------+   +-----------------+        |
|             |                 |   |                 |        |
|             | **状态寄存器** |   | **控制寄存器** |        |
|             | (Status Register)|   | (Control Register)|      |
|             | (由设备更新, CPU读) |   | (CPU写, 设备执行) |      |
|             |                 |   |                 |        |
|             +-----------------+   +-----------------+        |
|                                                             |
+-------------------------------------------------------------+
               |
               V
        +---------------+
        |  I/O 设备     |
        +---------------+
```


### 举一个具体的例子
假设打印机的**状态寄存器**和**控制寄存器**都映射到同一个 I/O 端口 `21H` (独立编址方式)。

1. **CPU 想读取打印机的状态（例如，是否空闲）**：
    
    - CPU 发出一条 `IN AL, 21H` 指令。
        
    - 这条指令会使 CPU 将端口地址 `21H` 放到 I/O 地址总线上，并发出一个**I/O 读（IOR#）**控制信号。
        
    - 打印机 I/O 接口的地址译码电路识别到 `21H`。
        
    - I/O 接口内部的读写控制逻辑检测到是**读操作**。
        
    - 于是，接口将**状态寄存器**中当前的 8 位状态信息放到数据总线上。
        
    - CPU 从数据总线上读取这些数据，存入 `AL` 寄存器。此时 `AL` 寄存器中存放的是打印机的**状态**。
        
2. **CPU 想向打印机发送一个控制命令（例如，启动打印）**：
    
    - CPU 发出一条 `OUT 21H, EEH` 指令（假设 `EEH` 是启动打印命令）。
        
    - 这条指令会使 CPU 将端口地址 `21H` 放到 I/O 地址总线上，将数据 `EEH` 放到数据总线上，并发出一个**I/O 写（IOW#）**控制信号。
        
    - 打印机 I/O 接口的地址译码电路识别到 `21H`。
        
    - I/O 接口内部的读写控制逻辑检测到是**写操作**。
        
    - 于是，接口将数据总线上的 `EEH` 写入到**控制寄存器**中。
        
    - 此时，控制寄存器中存放的是 `EEH`，打印机根据这个命令开始执行打印任务。状态寄存器的内容在此操作中不会改变（除非打印机本身的工作状态因命令而改变）。


### 总结
- **寄存器内容不相同**：状态寄存器和控制寄存器虽然可能共享同一个端口，但它们各自存储着不同的信息。状态寄存器存储的是设备当前的运行状态，由设备更新；控制寄存器存储的是 CPU 发送的命令或配置，由 CPU 写入。
    
- **读写操作是关键**：CPU 发出的**读写控制信号**是区分访问的是状态寄存器还是控制寄存器的核心机制。I/O 接口内部的硬件逻辑根据这些信号将数据路由到正确的寄存器。
