---
{"dg-publish":true,"dg-permalink":"/408/close()与write()操作的思考🤔","permalink":"/408/close()与write()操作的思考🤔/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

### 1. 写文件操作 (`write`)：高效但“懒惰”的数据搬运工

当我们调用`write()`函数向一个文件写入数据时，为了**极大地提高I/O效率**，操作系统通常不会立即把数据写入到慢速的磁盘上。磁盘I/O是一项非常耗时的操作（涉及寻道、旋转等机械动作）。如果每次`write`一两个字节就启动一次磁盘操作，系统性能将不堪设想。

因此，`write()`的典型流程是：

1. **数据从用户空间到内核空间**：程序调用`write()`时，数据从用户程序的缓冲区被复制到操作系统内核开辟的**I/O缓冲区（或称为页高速缓存 Page Cache）**中。
    
2. **快速返回**：一旦数据被复制到内核缓冲区，`write()`系统调用就可以**立即返回**，告诉用户程序“写入成功”。
    
3. **延迟写入 (Delayed Write)**：此时，数据只是存在于内存的内核缓冲区中，并没有被真正写入磁盘。内核会“攒”着这些数据，等到缓冲区满了、或者系统空闲时、或者定时任务触发时，再把整个缓冲区的数据一次性地、以一个或多个磁盘块为单位，高效地写入磁盘。
    

**`write()`操作的核心特征**：

- **异步性**: 对用户程序来说，`write()`的返回并不意味着数据已经安全地落在了磁盘上。
    
- **效率优先**: 它的主要目的是快速地将数据从用户进程“接管”过来，然后通过缓冲和批量写入的机制来优化性能。
    
- **不保证最终一致性**: 如果在`write()`调用后、数据被刷盘前，系统突然断电，那么这部分写入的数据将会**丢失**。
    

---

### 2. 关闭文件操作 (`close`)：确保善始善终的“收尾总管”

`close()`操作标志着一个进程对该文件访问的结束。因此，它必须承担起“善后”的全部责任，确保文件在磁盘上的状态是完整和一致的。

`close()`的典型流程是一个严谨的三部曲：

1. **第一步（最重要）：刷新内核数据缓冲区 (Flush Dirty Buffers)**
    
    - 操作系统会检查与该文件相关联的内核I/O缓冲区中，是否存在“脏数据”（即被修改过但尚未写入磁盘的数据）。
        
    - 如果存在，操作系统会**强制启动磁盘I/O**，将所有这些脏数据块**全部写回**到磁盘上。这个过程是**同步**的，`close()`会等待这个写操作完成后再继续。
        
    - **这步操作保证了所有之前`write()`的数据被永久化存储。**
        
2. **第二步：写回文件的控制信息（元数据 Metadata）**
    
    - 在确保了文件**内容**的完整性之后，操作系统会更新并写回文件的**“属性”**。这些控制信息存储在磁盘上的**文件控制块(FCB)**或**i-node**中。
        
    - 需要更新的典型信息包括：
        
        - **文件大小**: 经过多次写入，文件的尺寸可能已经改变。
            
        - **最后修改时间**: 记录文件内容最后一次被改变的时间戳。
            
        - **磁盘块指针**: 如果文件变大，可能需要分配新的数据块，这些新块的地址需要记录到i-node的指针列表中。
            
    - **为什么在此时写回？** 因为只有在所有数据都写入完毕后，文件的最终大小和状态才被完全确定。在每次`write`后都更新元数据会带来巨大的、不必要的I/O开销。
        
3. **第三步：释放内存中的控制结构**
    
    - 在确保磁盘上的数据和元数据都一致后，操作系统会释放为这次文件打开而分配的内存资源。
        
    - **在进程的“打开文件表”中，删除对应的表项**，从而释放该进程的文件描述符(fd)。
        
    - **在系统的“打开文件表”中，将对应表项的引用计数减1**。如果引用计数变为0（表示系统中已没有任何进程打开该文件），则释放这个系统级的表项。
        

---

### **总结与辨析表格**

|特性|写文件操作 (`write`)|关闭文件操作 (`close`)|
|---|---|---|
|**核心任务**|将数据从用户空间**传递**到内核缓冲区|**最终化**文件在磁盘上的状态，并**释放**内存资源|
|**数据同步性**|**通常是异步的**。调用返回不代表数据已落盘|**同步的**。会强制将缓冲数据刷到磁盘|
|**操作对象**|主要操作对象是**文件内容数据**|操作对象包括**数据**、**元数据**和**内核控制结构**|
|**对控制信息**|可能只更新内存中的副本（如当前文件指针）|**将最终的控制信息（大小、时间等）写回磁盘**|
|**I/O时机**|不一定会立即触发磁盘I/O|**会触发**必要的磁盘I/O以确保数据一致性|
|**资源管理**|占用和使用内核资源（如文件表项、缓冲区）|**释放**内核为此次文件打开所占用的资源|
