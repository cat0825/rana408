---
{"dg-publish":true,"dg-permalink":"/408/signal操作与V操作","permalink":"/408/signal操作与V操作/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

### 核心区别：有无“记忆”功能与状态改变

这是两者最根本的区别，也是所有其他差异的根源。

- **V 操作 (信号量)**: **具有记忆性**。`V(S)` 操作的本质是 `S.value++`。即使当前没有任何进程在等待该信号量，`V` 操作执行后，信号量 `S` 的值依然会加1。这个增加的值会被“记忆”下来，供后续的 `P` 操作使用。**它改变的是信号量本身的状态（资源计数）**。
    
    - **比喻**: `V` 操作就像往一个票箱里放一张票。不管现在有没有人在排队等票，这张票都会被放进去，供下一个来的人取用。
        
- **signal 操作 (管程)**: **不具有记忆性**。`signal(c)` 操作的本质是唤醒一个因条件 `c` 不满足而等待的进程。如果当前**没有**任何进程在条件变量 `c` 的等待队列上等待，那么 `signal` 操作将**不产生任何效果**，如同空操作一样，这个信号会立即被“丢弃”。**它试图改变的是另一个进程的状态（从等待到就绪），而不是条件变量本身的状态**。
    
    - **比喻**: `signal` 操作就像在候车室里喊一声：“车来了！” 如果有人在等车，他就会被唤醒准备上车；如果候车室里根本没人等这趟车，你喊的这一声就没有任何作用，声音消散了就没了。
        

---

### 运行环境与耦合度的区别

- **V 操作**: 是一个独立的操作，可以在程序的任何地方调用（只要能访问到信号量变量）。它与 `P` 操作松散地耦合，共同作用于一个全局或共享的信号量。
    
- **signal 操作**: 必须在**管程内部**使用。它总是与管程的互斥锁以及特定的条件变量 (`condition variable`) 紧密耦合。一个进程必须首先获得管程的互斥访问权，才能在管程的某个过程中调用 `wait` 或 `signal`。
    

---

### 导致进程状态改变的逻辑区别

- **V 操作**: `V(S)` 执行后，`S.value++`。如果 `S.value <= 0`，则说明之前有进程因 `P(S)` 而阻塞，此时 `V` 操作会唤醒一个等待的进程。唤醒的**直接原因**是 `S.value` 的值从负数向0靠近，代表“资源”从无到有。
    
- **signal 操作**: `signal(c)` 的执行逻辑是直接检查条件变量 `c` 的等待队列是否为空。如果不为空，则唤醒一个进程。唤醒的**直接原因**是另一个进程认为“等待的条件可能已经满足了”，并发出一个“通知”。
    

---

### 对当前执行进程的影响区别 

`V` 操作执行后，当前进程会继续执行，这是毫无疑问的。但 `signal` 操作执行后，当前进程（发信号者）和被唤醒进程（等待者）谁继续在管程内执行，这是一个重要的分歧点，在理论上分为两种模型：

1. **Hoare 风格 (霍尔风格)**: **立即切换，发信号者让权**。
    
    - 当进程 `A` 执行 `signal(c)` 唤醒了等待的进程 `B` 时，`A` 会**立即阻塞**自己，将管程的控制权（互斥锁）直接交给 `B`。
        
    - `B` 被唤醒后立刻在管程内继续执行。
        
    - **优点**: `B` 被唤醒时，它所等待的条件**一定**是真的。因为它是在 `A` 创造条件后、其他任何进程进入前立即执行的。因此，等待处的代码可以用 `if` 来判断。
        
    - **缺点**: 实现复杂，涉及两次额外的进程上下文切换（A->B，之后B退出或等待时又要唤醒A），开销较大。
        
2. **Mesa 风格 (米萨风格)**: **发信号者继续，等待者等待**。
    
    - 当进程 `A` 执行 `signal(c)` 唤醒了 `B` 时，`A` **并不会阻塞**，而是继续执行它在管程内的后续代码。
        
    - 被唤醒的 `B` 只是从条件等待队列移动到管程的**入口等待队列**，与其他希望进入管程的进程一起排队，等待 `A` 最终释放管程锁。
        
    - **缺点**: 当 `B` 最终被调度并重新获得管程锁时，它等待的条件**可能已经再次变为假**（因为在 `A` 发信号和 `B` 恢复执行之间，可能有其他进程进入管程并改变了状态）。因此，等待处的代码必须使用 `while` 循环来重新检查条件。
        
    - **优点**: 实现简单，上下文切换开销小。现代编程语言（如 Java 的 `notify()`）大多采用这种风格。
        

### 总结对比表格

| 特性          | V 操作 (信号量)                           | signal 操作 (管程)                                                                               |
| ----------- | ------------------------------------ | -------------------------------------------------------------------------------------------- |
| **核心机制**    | **有记忆性**，对资源计数器 `S.value` 进行 `++` 操作 | **无记忆性**，仅当有进程等待时才起作用，否则信号丢失                                                                 |
| **作用对象**    | 直接改变信号量 `S` 的状态值                     | 试图改变另一个进程的状态，对条件变量 `c` 本身无状态改变                                                               |
| **运行环境**    | 独立，可在任何能访问信号量的地方调用                   | 必须在管程内部，与管程互斥锁和条件变量强耦合                                                                       |
| **对当前进程影响** | 发信号的进程**总是继续执行**                     | **不一定**。Hoare风格下发信号者阻塞，Mesa风格下发信号者继续执行                                                       |
| **被唤醒后的状态** | 被唤醒的进程变为就绪态，等待CPU调度                  | 被唤醒的进程状态取决于管程风格 (Hoare:立即执行；Mesa:变为就绪态，等待管程锁)                                                |
| **使用范式**    | 成对的 `P`/`V` 操作，用于实现复杂的同步互斥逻辑         | `wait`/`signal` 成对出现，用于在管程内部管理"条件不满足则等待"的逻辑                                                  |
| **常见代码模式**  | `P(S)` ... `V(S)`                    | `while(!condition) wait(c);` ... `signal(c);` (Mesa风格) / `if(!condition) wait(c);` (Hoare风格) |

总而言之，`V` 操作是一个相对“低级”和“原始”的原子操作，它通过直接增减资源计数来协调进程。而 `signal` 是一个“高级”的、封装在管程结构内的通知机制，它将互斥和同步逻辑分离，使得程序结构更清晰，更不易出错。