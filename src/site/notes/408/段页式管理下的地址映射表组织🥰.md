---
{"dg-publish":true,"dg-permalink":"/408/段页式管理下的地址映射表组织🥰","permalink":"/408/段页式管理下的地址映射表组织🥰/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

在段页式管理中，每个进程的地址映射体系是这样组织的：

- **一个进程对应一张段表。**
    
- **每个段对应一张页表。**
    

---

### 2. 地址映射表的组织结构与原因

#### 2.1 为什么一个进程只有一张段表？

- **段表是进程逻辑地址空间的“目录”**: 在分段思想中，一个进程的整个逻辑地址空间是由它所拥有的所有“段”共同构成的。段表的作用就是这个进程所有段的总索引或总目录。CPU通过查询这张总目录，才能知道进程有哪些段，以及每个段的详细信息在哪里。
    
- **与进程上下文绑定**: 段表是描述一个进程内存布局的核心数据结构之一，它和进程控制块(PCB)一样，是进程上下文的重要组成部分。每个进程都需要自己独立的逻辑地址空间视图，因此每个进程都必须拥有自己私有的、唯一的段表。操作系统通过段表基址寄存器(STBR)来定位当前运行进程的段表。
    

所以，**一个进程** 对应 **一张段表**，这是由“进程作为资源分配和独立调度的基本单位”这一根本原则决定的。

#### 2.2 为什么每个段都有一张自己的页表？

这是段页式管理与单纯分页管理最核心的区别所在。

- **分页的对象是“段”而非“整个进程”**: 在单纯的分页系统中，页表映射的是整个**一维、线性**的进程逻辑地址空间。但在段页式系统中，分页是在分段的基础上进行的。系统不再为整个巨大的、统一的逻辑空间建立一张可能非常稀疏的页表，而是为**每一个逻辑上独立的段**建立一张属于它自己的页表。
    
- **段内地址的映射需求**: 逻辑地址被分为 `(段号, 段内页号, 页内偏移)`。当CPU通过段号在段表中找到对应表项后，它需要将地址的第二部分“段内页号”转换为物理页帧号。这个转换工作由谁来完成？答案就是这个段自己的页表。段表项中不再直接存放物理地址，而是存放该段对应的**页表的基地址**和**页表长度**。
    
- **提高空间利用率**: 这样做极大地提高了内存空间的利用率。在单纯的分页系统中，如果一个32位进程的逻辑地址空间非常大（4GB），但实际只使用了几小块内存（例如，一小块代码区，一小块数据区），那么也需要一个巨大的页表来映射整个4GB空间，其中绝大部分表项是空的，造成巨大浪费。而在段页式中，我们只需要为实际存在的、大小不一的段创建大小合适的页表即可，没有使用的巨大虚拟地址空间空洞将不会产生任何页表开销。
    

### 3. 地址映射过程


**逻辑地址: (段号 `S`, 段内页号 `P`, 页内偏移 `d`)**

1. **查段表**:
    
    - 用逻辑地址中的**段号 `S`** 去查询当前进程的**段表**。
        
    - 首先检查 `S` 是否越界（小于段表长度）。
        
    - 从段表中找到第 `S` 个表项，从中取出该段对应的**页表的基地址**和**页表长度**。
        
2. **查页表**:
    
    - 用逻辑地址中的**段内页号 `P`** 去查询上一步找到的**那个段的页表**。
        
    - 首先检查 `P` 是否越界（小于页表长度）。
        
    - 从该页表中找到第 `P` 个表项，从中取出该页对应的**物理页帧号**。
        
3. **形成物理地址**:
    
    - 将上一步得到的**物理页帧号**与逻辑地址中的**页内偏移 `d`** 进行拼接，最终形成访问主存的物理地址。
        

### 总结

- **组织结构**: **每个进程一张段表，每个段一张页表**。
    
- **原因**:
    
    - **一张段表**：因为段表是进程逻辑地址空间的总纲和目录，每个进程必须有自己独立的视图。
        
    - **多张页表**：因为分页是在分段的基础上对**各个独立的段**进行的，为每个段建立独立的页表可以有效避免为巨大而稀疏的虚拟地址空间建立一个同样巨大而浪费的单一页表，从而大大节省了存储页表的空间开销。