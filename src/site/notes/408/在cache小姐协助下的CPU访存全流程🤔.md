---
{"dg-publish":true,"dg-permalink":"/408/在cache小姐协助下的CPU访存全流程🤔","permalink":"/408/在cache小姐协助下的CPU访存全流程🤔/"}
---


### 一、 带 Cache 的 CPU 访存完整流程

CPU执行一条访存指令（读或写）时，并不会直接与主存打交道，而是优先与Cache交互。整个流程如下：

1. **CPU发出请求：** CPU产生一个内存地址（逻辑地址，经过MMU转换为物理地址），并连同读/写信号一起发送给Cache控制器。
    
2. **Cache命中判断 (Cache Hit / Miss):** 这是流程的关键分水岭。
    
    - Cache控制器根据地址的**索引字段 (Index)** 定位到Cache中的某一个或某一组Cache行。
        
    - 然后，比较地址的**标记字段 (Tag)** 与该Cache行中存储的标记是否一致。
        
    - 同时，检查该Cache行的**有效位 (Valid Bit)** 是否为1。
        
    - **如果** `标记匹配` 且 `有效位为1`，则判断为 **“Cache命中 (Cache Hit)”**。
        
    - **否则**，即为 **“Cache缺失 (Cache Miss)”**。
        
3. **后续操作：**
    
    - **若命中 (Hit):**
        
        - **读命中：** Cache控制器直接从命中的Cache行中，根据地址的**块内偏移字段 (Offset)**，取出对应的字节或字，通过内部总线高速地传送给CPU。访存操作快速完成。
            
        - **写命中：** 根据写策略（Write Policy）进行操作。
            
            - **写直通 (Write-Through):** 同时写入Cache和主存。
                
            - **写回 (Write-Back):** 只写入Cache，并将该Cache行标记为“脏”(Dirty)。该行的数据只有在被替换时，才会被写回主存。
                
    - **若缺失 (Miss):** 系统将启动一套相对复杂的“缺失处理机制 (Miss Handling)”。
        

---

### 二、 缓存缺失 (Cache Miss) 的处理机制

**如果Cache缺失，访问主存和更新Cache是同时完成的吗？**

**不是同时完成的，这是一个有明确先后逻辑顺序的过程，但现代CPU通过优化技术使其部分操作可以并发执行，从而缩短延迟。**

下面是标准的、逻辑上的处理步骤：

#### 步骤 1：暂停CPU (Stall the CPU)

当发生Cache Miss时，CPU无法立即获得它想要的数据，因此其执行流水线会**暂停 (Stall)**，等待数据从主存中取回。

#### 步骤 2：访问主存 (Access Main Memory)

Cache控制器会接管后续工作，向主存控制器发出一个**读请求**。

- **关键点：** 这个读请求请求的**不是CPU最初需要的那个字**，而是包含了那个字在内的**一整个主存块 (Block/Line)**。这是利用了程序的**空间局部性原理**，即CPU访问了某个地址后，很可能在不久的将来访问其附近的地址。将整个块调入Cache可以提高后续访问的命中率。
    

#### 步骤 3：数据从主存调往Cache (Block Transfer)

主存响应请求，找到对应的数据块，通过系统总线将其传输给Cache控制器。

#### 步骤 4：数据交付与Cache更新 (重点！)

这是最关键的一步，它直接回答了你的问题。当数据块从主存传输过来时，发生了两件事：

- A. 将CPU所需的字直接送往CPU (CPU Forwarding / Critical Word First)
    
    为了尽快地让CPU从暂停状态中恢复，大多数Cache控制器采用了**“读穿 (Read-Through)”或称“关键宇优先”技术。即在整个数据块还在从主存流向Cache的途中，一旦CPU最先需要的那个字到达了，Cache控制器就会立即将这个字直接“转发”给CPU**。这样CPU就可以继续执行，不必等待整个块完全写入Cache。
    
- B. 将整个数据块写入Cache (Cache Line Fill)
    
    在将关键字发送给CPU的同时，或者之后，Cache控制器会执行以下操作来更新Cache：
    
    1. **选择替换行：** 从Cache的对应组中，根据**替换算法 (Replacement Algorithm)**（如LRU, FIFO等）选择一个Cache行用于存放新调入的数据块。
        
    2. **处理脏块 (Dirty Block)：** 如果被选中的替换行是“脏”的（即在写回策略下，该行数据被修改过），则必须**先将这一整行旧的“脏”数据写回主存**，这个过程称为“写回 (Write-Back)”。这会增加本次Cache Miss的处理时间（Miss Penalty）。
        
    3. **写入新块：** 将从主存调入的新数据块写入被选中的Cache行。
        
    4. **更新元数据：** 更新该Cache行的**标记 (Tag)** 和**有效位 (Valid Bit)**。
        

#### 流程总结与回答

- **从逻辑上讲，是“先访问主存，再更新Cache”**。因为没有从主存取回数据，就无法进行更新。
    
- **从执行效率上讲，为了缩短CPU的等待时间，将数据送往CPU和将数据块写入Cache这两个动作是高度并发的**。CPU不必等到整个Cache行更新完毕，通过“关键宇优先”技术，它可以提前拿到需要的数据。
    
---

### 三、 考点分析与陷阱

1. **Cache缺失代价 (Miss Penalty):** 这是衡量Cache性能的重要指标，指的是从发生缺失到CPU获得数据所需的时间。其主要构成是**访问主存的时间**。
    
2. **写回策略的额外开销：** 考题中经常会涉及计算Cache缺失的代价。一个常见的陷阱是，如果替换策略选中了一个“脏块”，考生必须记得加上**将脏块写回主存的时间**。
    
3. **“关键宇优先”技术：** 这个概念是理解Cache效率的关键。它解释了为什么在Cache缺失后，CPU的停顿时间可以小于“主存访问时间 + Cache更新时间”的总和。
    
4. **数据块传输：** 一定要牢记，Cache和主存之间的数据交换单位是**块 (Block)**，而不是字 (Word)。这是Cache工作的基础，也是利用空间局部性原理的体现。