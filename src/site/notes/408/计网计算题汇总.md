---
{"dg-publish":true,"dg-permalink":"/408/计网计算题汇总","permalink":"/408/计网计算题汇总/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

## 第一节：物理层

### 1.1 数据传输速率极限：奈奎斯特与香农

信道容量由两个基本定理界定。奈奎斯特（Nyquist）定理描述了无噪声信道的最大数据速率，将其与带宽和信号电平数关联。而香农（Shannon）定理则给出了噪声信道的终极速率极限，将其与带宽和信噪比（SNR）联系起来。

奈奎斯特定理：在无噪声环境下，为避免码间串扰，最大数据传输速率为 $$C=2H\log_2(V)$$，其中 $C$ 是信道容量（单位bps），$H$ 是带宽（单位Hz），$V$ 是离散信号电平或状态的数量。例如，一个问题给出带宽为3kHz，采用4个相位和4种振幅的QAM调制，这意味着信号共有 $$V=4\times4=16$$ 种状态。因此，最大数据传输速率为 $$C=2\times3000\times\log_2(16)=2\times3000\times4=24000\ \text{bps}=24\ \text{kbps}$$。

香农定理：在有噪声的信道中，理论最大数据传输速率为 $$C=H\log_2(1+S/N)$$，其中 $S/N$ 是信噪比（信号功率与噪声功率之比）。信噪比通常以分贝（dB）给出，需要通过公式 $$S/N=10^{(dB/10)}$$ 进行转换。例如，若链路带宽为8kHz，信噪比为30dB，则首先计算 $$S/N=10^{(30/10)}=1000$$。理论最大速率为 $$C=8000\times\log_2(1+1000)\approx8000\times\log_2(1024)=8000\times10=80\ \text{kbps}$$。如果题目附加条件，如实际速率是理论的50%，则最终结果为40kbps。

这两个定理并非孤立存在，它们共同描述了信道能力的两个不同维度。奈奎斯特关注的是在给定时间内可以发送多少个不同的符号而不会相互混淆（码间串扰问题），而香农则关注在噪声背景下可以可靠地区分多少个信号级别（噪声容限问题）。一个更深入的问题可能会要求在这两个理论之间建立联系，例如，计算需要多少个信号状态（奈奎斯特的 $V$）才能达到或超过某个给定信噪比下的香农容量。这需要求解不等式 $$2H\log_2(V)\geq H\log_2(1+S/N)$$从而将抽象的理论极限（香农）与具体的调制方案（奈奎斯特的 $V$）联系起来。

### 1.2 传输时间与交换延迟

网络延迟由多个部分组成，其中最核心的是传输延迟和传播延迟。

传输延迟 ($T_d$)：将一个报文或分组的所有比特推向链路所需的时间，计算公式为 $$T_d=\text{报文长度}/\text{带宽}$$
传播延迟 ($T_p$)：一个比特从链路一端传播到另一端所需的时间，计算公式为 $$T_p=\text{距离}/\text{传播速度}$$
在采用"存储-转发"机制的分组交换网络中，总延迟的计算需要考虑流水线效应。例如，一个大小为980000B的文件，通过100Mbps的链路发送，分组大小为1000B（其中20B为头部），则数据载荷为980B。文件共需分为 $980000/980=1000$ 个分组。若路径经过两个路由器（三段链路），总时间由第一分组到达目的地的时间和其余分组流出的时间组成。第一个分组到达需经过3次传输，总时间为 $3\times T_d$之后，每经过一个 $T_d$ 的时间，就有一个新的分组到达。因此，总时间为 $$3\times T_d+(1000-1)\times T_d=1002\times T_d$$这种流水线机制显著优于报文交换，在报文交换中，整个文件必须在每个节点被完整接收后才能转发，总时间为 $3\times(\text{文件总大小}/\text{带宽})$

### 1.3 信号编码与波特率

数据传输速率（比特率）和信号传输速率（波特率）是两个不同的概念。它们之间的关系由公式 $$\text{数据速率}=\text{波特率}\times\log_2(V)$$ 描述，其中 $V$ 仍然是信号状态的数量。波特率表示每秒钟信号变化的次数，而比特率表示每秒钟传输的二进制比特数。例如，若数据传输速率为2400bps，采用四相位调制（$V=4$），则波特率为 $$2400/\log_2(4)=2400/2=1200\ \text{波特}$$

| 概念 |公式 |变量说明 |
| ---|---|---|
| 奈奎斯特定理 (无噪声) |$$C=2H\log_2(V)$$ |$C$: 容量 (bps), $H$: 带宽 (Hz), $V$: 信号电平数 |
| 香农定理 (有噪声) |$$C=H\log_2(1+S/N)$$ |$C$: 容量 (bps), $H$: 带宽 (Hz), $S/N$: 信噪比 |
| 分贝与信噪比转换 |$$S/N=10^{(dB/10)}$$ |$S/N$: 功率比, $dB$: 分贝 |
| 传输延迟 |$$T_d=L/R$$ |$L$: 报文/分组大小 (bits), $R$: 带宽 (bps) |
| 传播延迟 |$$T_p=d/v$$ |$d$: 距离 (m), $v$: 传播速度 (m/s) |
| 分组交换总时间 |$$T_{\text{total}}=(k+N-1)\times T_d$$ |$k$: 链路跳数, $N$: 分组数, $T_d$: 单个分组的传输延迟 |

## 第二节：数据链路层


### 2.1 流量控制与可靠数据传输

滑动窗口协议是数据链路层实现可靠传输的核心。其性能，特别是信道利用率，是计算的重点。所有滑动窗口协议的性能都可以由一个统一的通用模型来描述。信道利用率 $U$ 指的是在一个发送周期内，发送方用于发送有效数据的时间占总时间的比例。

一个发送周期从发送第一个数据帧开始，到接收到它的确认为止，总时长至少为一个往返时间（RTT），即 $T_d+2T_p$（其中 $T_d$ 是数据帧的传输延迟，$T_p$ 是单向传播延迟）。在停-等协议中，发送窗口 $W=1$，发送方在此周期内只发送一个帧，因此信道利用率 $$U=T_d/(T_d+2T_p)$$。对于窗口大小为 $W$ 的滑动窗口协议，发送方可以在一个RTT内连续发送 $W$ 个帧，因此有效工作时间为 $W\times T_d$。信道利用率的通用公式为：

$$U=\frac{W\times T_d}{T_d+2T_p}$$

这个公式是解决此类问题的关键。不同的问题只是从不同角度考察对这个公式的理解和应用。例如：

求最大数据传输速率：最大平均速率 = 带宽 × 最大信道利用率 $U$。如在后退N帧（GBN）协议中，给定发送窗口 $W$、帧长、带宽和传播延迟，可以计算出 $U$ 并求得最大速率。

求最小帧序号比特数：为达到某个信道利用率（如80%），可以反推出所需的最小窗口大小 $W$。根据协议类型（GBN或SR）和窗口大小 $W$，可以确定编码序号所需的最小比特数 $n$（例如，对于GBN，需满足 $$W\leq 2^n-1$$）。

求数据帧长度：在停-等协议中，如果已知信道利用率、带宽和传播延迟，可以反推出传输延迟 $T_d$，进而计算出数据帧的长度。

此外，不同协议的重传策略也影响计算。在GBN中，当计时器超时，发送方需要重传所有已发送但未确认的帧。例如，若已发送0-7号帧，只收到0、2、3号帧的确认，由于GBN采用累积确认，收到ACK3意味着0、1、2、3都已收到，但题目说只收到0、2、3的确认，这暗示了GBN的实现细节，若ACK1丢失，则发送方认为1号帧及之后所有帧都需重传。若只收到0、2、3的确认，说明1号帧的确认未到，因此发送方需要重传从1号帧开始的所有未确认帧，即1, 4, 5, 6, 7，共5个帧。而在选择重传（SR）协议中，仅重传超时的帧，例如0、2号帧超时，则只需重传这两个帧。

| 特性 |停-等协议 (Stop-and-Wait) |后退N帧协议 (Go-Back-N) |选择重传协议 (Selective Repeat) |
| ---|---|---|---|
| 发送窗口 ($W_s$) |1 |$$1\leq W_s\leq 2^n-1$$ |$$1\leq W_s\leq 2^{(n-1)}$$ |
| 接收窗口 ($W_r$) |1 |1 |$$1\leq W_r\leq 2^{(n-1)}$$ |
| 确认机制 |确认单个帧 |累积确认 (确认到n-1) |确认单个帧 |
| 重传策略 |超时重传当前帧 |超时重传整个窗口 |超时仅重传丢失的帧 |
| 接收方缓存 |无需缓存乱序帧 |丢弃所有乱序帧 |缓存并确认乱序帧 |

### 2.2 介质访问控制 (MAC)

在共享介质网络中，核心计算围绕CSMA/CD协议的冲突检测机制。为了确保发送方在发送完一个帧之前能检测到可能发生的冲突，帧的传输时延必须不小于信号在网络中往返传播的最大时延（即争用期 $2\tau$）。这引出了核心不等式：

$$\frac{L_{\text{min}}}{R}\geq 2\tau=2\frac{d_{\text{max}}}{v}$$

其中 $L_{\text{min}}$ 是最小帧长， $R$ 是数据传输速率， $d_{\text{max}}$ 是网络中任意两站点间的最大距离， $v$ 是信号传播速度。

这个不等式是解决CSMA/CD相关计算问题的基础。

若最小帧长减少，为维持不等式成立，必须相应地减少最大距离 $d_{\text{max}}$。

若已知最小帧长和传输速率，可以计算出允许的最大单向传播时延 $\tau$，从而确定冲突域的最大跨距。

在计算争用期时，还需考虑网络设备（如中继器、集线器）引入的延迟。此时，$$\tau=\frac{d_{\text{max}}}{v}+\text{设备延迟}$$

对于码分多址（CDMA），计算主要涉及码片的正交性。每个站点被分配一个唯一的m位码片序列。要恢复某个站点发送的数据，接收方只需将收到的混合信号与该站点的码片序列进行规格化内积运算。例如，站点A的码片为(1,1,1,1)，B为(1,-1,1,-1)，C为(1,1,-1,-1)。若C收到混合序列S=(2,0,2,0)，要解码A发送的数据，计算 $$S\cdot A=(2\times1+0\times1+2\times1+0\times1)/4=1$$。这意味着A发送了比特1。

## 第三节：网络层

### 3.1 IP地址、子网划分与路由聚合

IP地址的计算是网络层最基本也是最重要的定量技能，其核心是二进制运算。

子网划分 (Subnetting)：通过借用主机位来创建更多的网络位，从而将一个大的网络地址块划分为多个较小的子网。计算内容包括：

确定子网掩码：根据所需的子网数量或每个子网的主机数量来确定。例如，将一个/24网络划分为至少120个可用IP地址的子网，每个子网需要 $N$ 个主机位，满足 $$2^N-2\geq 120$$，解得 $N=7$。因此子网掩码需要 $$32-7=25$$ 位，即/25。

计算网络地址：将IP地址与子网掩码进行按位与（AND）运算。

计算广播地址：将网络地址的主机位全部置为1。

计算可用主机范围：网络地址+1 到 广播地址-1。

这些计算在大量问题中反复出现。

路由聚合 (Aggregation/CIDR)：与子网划分相反，路由聚合是将多个连续的子网地址块合并成一个更概括的超网地址，以减小路由表的规模。其计算方法是将所有待聚合的地址写成二进制形式，找到它们共同的最长前缀，该前缀即为聚合后的网络地址。

最长前缀匹配：这是路由器转发决策的核心算法。当一个IP数据报到达时，路由器会用其目的IP地址与路由表中的所有条目进行匹配，并选择具有最长匹配前缀（即子网掩码最长）的路由条目进行转发。这保证了数据包总是被发送到最精确的目的地。

子网划分和路由聚合体现了一种设计上的对偶性。网络管理员通过聚合来压缩路由信息，创建层次化的、可扩展的路由表。而路由器则通过最长前缀匹配来"解压"这些信息，为每个数据包找到最具体的转发路径。聚合创造了路由的模糊性（一个地址可能匹配多个路由条目），而最长前缀匹配则是解决这种模糊性的规则。

### 3.2 IP分片

当一个IP数据报的大小超过其即将经过的链路的最大传输单元（MTU）时，路由器必须对其进行分片。分片计算涉及IP头部的几个关键字段：

总长度 (Total Length)：每个分片的IP包总长度。

标识 (Identification)：同一数据报的所有分片具有相同的标识号。

标志位 (Flags)：DF位（Don't Fragment）和MF位（More Fragments）。除最后一个分片外，所有分片的MF位都为1。

片偏移 (Fragment Offset)：表示该分片的数据部分在原始数据报中的起始位置，以8字节为单位。

计算的关键在于，除了最后一个分片，每个分片的数据载荷长度必须是8的倍数。例如，一个总长1580B（头部20B，数据1560B）的IP包，要通过MTU为800B的链路。每个分片的最大数据载荷为 $$800-20=780\text{B}$$。但780不是8的倍数，必须向下取整到最近的8的倍数，即776B。

第一个分片：总长 $776+20=796\text{B}$，MF=1，片偏移=0。

第二个分片：剩余数据 $1560-776=784\text{B}$。第二个分片可以承载这784B（是8的倍数）。总长 $784+20=804\text{B}$，这超过了MTU。因此第二个分片也只能载776B。总长796B，MF=1，片偏移为 $776/8=97$。

第三个分片：剩余数据 $784-776=8\text{B}$。总长 $8+20=28\text{B}$，MF=0，片偏移为$(776+776)/8=194$。

### 3.3 路由协议计算

路由协议的计算主要体现在距离向量协议（如RIP）的路由更新上。

RIP (Routing Information Protocol)：使用跳数作为度量。当一个路由器收到邻居发来的距离向量更新时，它会应用贝尔曼-福特（Bellman-Ford）方程的变体来更新自己的路由表。对于每个目的网络N，新的距离计算为：

$$\text{Dist}_{\text{new}}(N)=\min_{\text{neighbor}\ X}\{Cost(X)+\text{Dist}_X(N)\}$$

在RIP中，到邻居的成本（Cost）固定为1。例如，路由器E收到邻居A、B、C、D的距离向量，它到这些邻居的链路成本分别为8, 10, 12, 6。对于目的网络Net1，A、B、C、D通告的距离分别是23, 20, 1, 22。E通过各邻居到达Net1的距离分别为 $$8+23=31$$, $$10+20=30$$, $$12+1=13$$, $$6+22=28$$。E会选择最小的路径，即通过C，距离为13。

"无穷大"度量：RIP将16跳定义为不可达。当一个路由器检测到某网络不可达时，它会向邻居通告该网络的距离为16。这用于防止路由环路（"计数到无穷"问题）。

## 第四节：传输层

传输层的计算问题几乎完全集中在TCP协议上，它为不可靠的网络层提供了可靠、有序、流量控制和拥塞控制的服务。其动态窗口机制是计算的核心和难点。

### 4.1 TCP序列号 (SEQ) 与确认号 (ACK)

理解TCP计算的前提是掌握其字节流编号机制：

序列号 (SEQ)：TCP对发送的每个字节进行编号。一个TCP段的序列号是该段所携带数据中第一个字节的编号。

确认号 (ACK)：确认号是期望从对方接收的下一个字节的序列号。它具有累积性，ACK=N表示N-1之前的所有字节都已正确接收。

SYN/FIN消耗序列号：建立连接的SYN报文和断开连接的FIN报文虽然不携带应用数据，但它们各自消耗一个序列号。

基于这些规则，可以进行多种计算。例如，计算一次完整TCP连接传输的应用数据量。若客户端发起连接的SYN报文序号为1000，断开连接时发送的FIN报文序号为5001，则此连接中客户端共发送了 $$5001-(1000+1)=4000$$ 字节的应用层数据。

### 4.2 TCP流量控制与拥塞控制：动态窗口

TCP的发送行为由一个动态变化的窗口控制，这个窗口的大小是流量控制窗口（接收方窗口 rwnd）和拥塞控制窗口（cwnd）的较小值。

$$\text{发送窗口}=\min(\text{cwnd},\text{rwnd})$$

对cwnd演变的追踪是解决TCP拥塞控制问题的关键。可以将TCP的拥塞控制算法视为一个状态机，其状态由 ($\text{cwnd}$, $\text{ssthresh}$) 元组定义，由网络事件（收到新ACK、收到重复ACK、超时）触发状态转移。

慢开始 (Slow Start)：当 $\text{cwnd} < \text{ssthresh}$ 时，每经过一个RTT，$\text{cwnd}$ 翻倍（指数增长）。

拥塞避免 (Congestion Avoidance)：当 $\text{cwnd}$ ≥ $\text{ssthresh}$ 时，每经过一个RTT，$\text{cwnd}$ 增加1个MSS（线性增长）。

超时事件：当发生超时，TCP认为网络发生严重拥塞。它会执行：
$$\text{ssthresh}=\text{cwnd}/2$$
$$\text{cwnd}=1\ \text{MSS}$$
重新进入慢开始阶段。

快速重传/恢复：当收到3个重复的ACK时，TCP认为只是个别分组丢失，而非网络瘫痪。它会执行：
$$\text{ssthresh}=\text{cwnd}/2$$
$$\text{cwnd}=\text{ssthresh}+3\ \text{MSS}$$
直接进入拥塞避免阶段。

通过构建一个状态追踪表，可以清晰地解决各类$\text{cwnd}$演变问题。例如，一个TCP连接在$\text{cwnd}$为8KB时发生超时，MSS为1KB，接收窗口足够大。其$\text{cwnd}$的演变过程如下表所示：

| 事件/时刻 |RTT 周期 |$\text{cwnd}$  (KB) |$\text{ssthresh}$  (KB) |阶段 |备注 |
| ---|---|---|---|---|---|
| 正常传输 |t=0 |8 |(较高) |拥塞避免 |初始状态 |
| 超时发生 |t=0 |- |- |- |网络事件 |
| 状态更新 |t=0 |1 |4 |慢开始 |$$\text{ssthresh}=8/2=4$$, $$\text{cwnd}=1$$ |
| 收到ACK |t+1 RTT |2 |4 |慢开始 |$\text{cwnd}$  翻倍 |
| 收到ACK |t+2 RTT |4 |4 |慢开始 |$\text{cwnd}$  翻倍, 达到  $\text{ssthresh}$ |
| 收到ACK |t+3 RTT |5 |4 |拥塞避免 |进入线性增长,  $\text{cwnd}$  加1 |
| 收到ACK |t+4 RTT |6 |4 |拥塞避免 |$\text{cwnd}$  加1 |
| ... |... |... |... |... |... |

通过这种方法，可以精确计算出在任意RTT后$\text{cwnd}$的大小，或者计算$\text{cwnd}$从一个值增长到另一个值所需的时间。同时，还需注意接收方窗口 $\text{rwnd}$ 的限制。$\text{rwnd}$ 的值由接收方在其发送的ACK段中通告，等于其接收缓存的空闲空间。发送方的实际发送窗口不能超过$\text{rwnd}$。

## 第五节：应用层

应用层的计算问题通常是端到端性能的综合体现，它将底层所有延迟累加起来，计算完成一个特定应用任务（如加载一个网页）所需的总时间。

### 5.1 DNS与HTTP性能计算

加载一个网页的总时间，其核心是"计算往返时间（RTT）的次数"。一个RTT是数据包从客户端发出到收到服务器响应所经过的时间，是网络交互的基本时间单位。

$$T_{\text{total}}=T_{\text{DNS}}+T_{\text{TCP}}+T_{\text{HTTP}}$$

DNS解析时间 ($T_{\text{DNS}}$)：
最佳情况：域名在本机或本地域名服务器缓存中，时间可能接近0或只需1个RTT（到本地域名服务器）。
最差情况：无缓存，需要从客户端到本地域名服务器（递归查询，1个RTT），再由本地域名服务器向根、顶级域、权威域名服务器进行迭代查询（每个查询1个RTT）。总共可能需要4个或更多的RTT。

TCP连接建立时间 ($T_{\text{TCP}}$)：
标准的三次握手过程需要1个RTT。

HTTP传输时间 ($T_{\text{HTTP}}$)：
这部分时间取决于HTTP协议版本和页面内容。
HTTP/1.0 (非持续连接)：每个对象（HTML文件、图片等）都需要建立一个新的TCP连接，因此每个对象耗时 $1\ \text{RTT}\ (\text{TCP})+1\ \text{RTT}\ (\text{HTTP})$。
HTTP/1.1 (持续非流水线)：多个对象共享一个TCP连接，节省了后续对象的TCP握手时间。加载一个HTML页面和5个图片，需要 $$1\ \text{RTT}\ (\text{TCP})+1\ \text{RTT}\ (\text{HTML})+5\times1\ \text{RTT}\ (\text{图片})=7\ \text{RTTs}$$。
HTTP/1.1 (持续流水线) & HTTP/2 (多路复用)：允许并行请求，进一步减少了RTT的串行等待。例如，加载一个HTML页面和一张图片，在建立TCP连接后，可能只需要 $$1\ \text{RTT}\ (\text{HTML})+1\ \text{RTT}\ (\text{图片})$$，总共 $$1+1+1=3$$ 个RTT。

可以看出，从HTTP/1.0到HTTP/2的演进，其核心目标之一就是减少完成页面加载所需的RTT总数。因此，解决应用层性能问题的关键，就是仔细分析任务流程，将其分解为一系列依赖的或并行的网络交互，然后精确地计算出总共需要多少个RTT。

## 汇总表

| 类别 |典型计算内容/关键字 |考察核心知识点 |所属网络层 |
| ---|---|---|---|
| 带宽与信道容量 |最大数据传输速率、调制电平、信噪比 |奈奎斯特和香农公式，波特率与比特率的关系 |物理层 |
| 传输与存储转发时延 |文件分割传输时间、报文交换/分组交换 |传输时延 vs. 传播时延、分组转发过程 |物理层↔网络层 |
| 停–等/滑动窗口协议 |信道利用率、最小帧长、序号位数 |$$U=T_x/(T_x+2\tau)$$、窗口大小与编号范围、序号/确认逻辑 |数据链路层 |
| 介质访问控制与CSMA/CD |最小帧长、最大距离、CDMA 解码 |最短帧与往返传播时延、集线器延迟、码片正交性 |数据链路层 |
| IP地址与子网划分 |网络地址、广播地址、可用地址数、路由聚合 |按位掩码计算、借位与前缀聚合、默认网关配置 |网络层 |
| IP 分片 |分片大小、片偏移、MF 标志 |MTU 限制、$$8\ \text{B}$$ 对齐、分片序列与组合 |网络层 |
| 路由与转发 |输出接口选择、路由表设计 |最长前缀匹配、路由聚合与策略 |网络层 |
| TCP 序号/窗口与拥塞控制 |序号/确认号、可发送字节数、窗口增长时间 |累积确认、流量控制、拥塞控制算法、慢开始与拥塞避免 |传输层 |
| UDP/TCP 传输效率 |有效载荷比例 |UDP 与 TCP 头部开销与填充 |传输层 |
| DNS/HTTP 时延 |查询次数、RTT 计数、连接建立时间 |递归与迭代查询、三次握手、持久连接与流水线 |应用层 |