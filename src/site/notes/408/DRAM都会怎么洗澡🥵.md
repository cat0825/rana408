---
{"dg-publish":true,"dg-permalink":"/408/DRAM都会怎么洗澡🥵","permalink":"/408/DRAM都会怎么洗澡🥵/","dgShowBacklinks":true,"dgShowLocalGraph":true,"dgShowInlineTitle":true}
---

### DRAM的三种基本刷新策略

#### 1. 集中式刷新 (Centralized Refresh / Burst Refresh)

- 原理与执行方式：
    
    这是一种最简单直接但最“粗暴”的策略。DRAM芯片在规定的刷新周期（如64ms）内，绝大部分时间都正常响应CPU的读写请求。但在该周期的末尾，找到一个空闲时间，暂停所有对存储器的访问，然后启动一个连续的、不间断的**“刷新脉冲串 (Burst)”**，一次性地、连续地对所有行（例如全部8192行）进行刷新，直到所有行都被刷新完毕。
    
- 流程示意：
    
    [---------- 正常读写周期 (接近64ms) ----------][-- 死区: 连续刷新所有行 --]
    
- "死时间"分析：
    
    假设刷新一个行需要一个时钟周期（例如100ns），那么刷新8K（8192）行就需要：
    
    T死区​=8192×100ns=819.2μs
    
    在这长达819.2微秒的时间内，CPU或任何其他设备都无法访问内存，内存完全处于“死机”状态，不响应任何读写请求。
    
- **优点：**
    
    - **控制简单：** 内存控制器的逻辑非常简单，只需要一个定时器，在刷新周期结束前触发一次集中的刷新操作即可。读写逻辑和刷新逻辑完全分离。
        
- **缺点：**
    
    - **存在明显的“死区”**：这是其致命缺点。在刷新期间，内存完全不可用，对于需要实时响应的系统（如工业控制、实时操作系统）是绝对无法接受的。
        
- **适用场景：**
    
    - 由于存在严重的“死区”问题，**集中式刷新在现代通用计算机系统中基本不被采用**。它更多是作为一个理论模型，用于教学和理解刷新概念。可能仅适用于某些对实时性要求极低、且允许有固定长暂停的嵌入式或专用系统中。
        

#### 2. 分散式刷新 (Decentralized Refresh / Distributed Refresh)

- 原理与执行方式：
    
    这种策略将刷新操作均匀地分散到整个刷新周期内。它将刷新周期（如64ms）平分给所有需要刷新的行（如8192行），计算出两次刷新操作之间的最大时间间隔。
    
    刷新间隔=8192行64ms​≈7.8μs
    
    这意味着，内存控制器必须保证每7.8μs就执行一次行刷新操作。这个刷新周期被穿插在正常的读写周期之间。
    
- 流程示意：
    
    [读/写] [读/写] ... [刷新行i] [读/写] [读/写] ... [刷新行i+1] ...
    
    存储器的每个工作周期实际上由一个读/写操作和一个刷新操作构成。
    
- "死时间"分析：
    
    分散式刷新没有集中的、长的“死区”。但它把刷新的时间开销“摊派”到了每一次存储器访问中，使得每个存储周期的总时间被拉长了。例如，一个正常的读写周期可能是80ns，但为了插入刷新，整个系统周期可能被定义为100ns，预留了刷新操作的时间。
    
- **优点：**
    
    - **无长“死区”**：系统响应不会有长时间的中断，实时性得到了保证。
        
- **缺点：**
    
    - **降低了整体性能：** 即使在读写不频繁、总线空闲的时候，也必须严格按照固定的时间间隔插入刷新，这会拖慢系统运行速度。在需要密集读写的场景下，频繁的刷新插入会严重影响带宽。
        
    - **控制相对复杂：** 需要更精细的时序控制来保证刷新周期的精确插入。
        
- **适用场景：**
    
    - 适用于**对实时性要求高**、不允许出现长暂停的系统。虽然它也不是现代主流PC的选择，但其设计思想对实时系统有重要意义。
        

#### 3. 异步式刷新 (Asynchronous Refresh / Staggered Refresh)

- 原理与执行方式：
    
    这是集中式和分散式的折中方案，也是现代计算机系统普遍采用的策略。它同样要求在64ms内刷新完所有行（如8K行），因此平均下来也是每7.8μs需要刷新一行。但它不要求严格地在固定时间点进行刷新。控制器只需要保证在一个刷新周期（64ms）内，发出了足够次数（8192次）的刷新命令即可。
    
- 流程示意：
    
    它将刷新操作分解为对单行的刷新，可以在CPU不访问内存的空闲时间，或者对性能影响较小的时机，见缝插针地进行。控制器可以一次性刷新几行，也可以在一段时间内不刷新（只要不超出单行电荷泄漏的最大时限），只要最终能“完成任务”即可。
    
- "死时间"分析：
    
    异步刷新既避免了集中式的长“死区”，也避免了分散式的死板。单次刷新一行的时间非常短（如100ns），对系统的影响可以降到最低。
    
- **优点：**
    
    - **性能影响最小：** 提供了极大的灵活性，可以在总线空闲时进行刷新，最大化了读写操作的有效带宽。这是**性能最好**的刷新方式。
        
    - **实时性好：** 避免了长“死区”，保证了系统的及时响应。
        
- **缺点：**
    
    - **控制最复杂：** 内存控制器需要更智能的逻辑，不仅要跟踪刷新进度，还要判断总线状态，以寻找最佳的刷新时机。
        
- **适用场景：**
    
    - **几乎所有现代计算机系统**，包括个人电脑、服务器、智能手机等。这是因为它在性能和实时性之间取得了最佳的平衡。
        

---

### 总结对比

|特性|集中式刷新|分散式刷新|异步式刷新|
|---|---|---|---|
|**刷新方式**|周期末尾，一次性刷新所有行|均匀分散，穿插在读写周期中|在周期内，见缝插针地刷新各行|
|**“死区”**|**长且固定**，整个系统暂停|**无**，但每个存储周期被拉长|**极短**，对系统影响微乎其微|
|**对读写影响**|影响集中在“死区”时间段|影响分散到每一次操作，整体降速|影响最小，利用空闲周期|
|**控制复杂度**|**简单**|较复杂|**最复杂**|
|**适用场景**|理论教学，极少数特定系统|对实时性有严格要求的系统|**现代通用计算机系统标准方案**|