---
{"dg-publish":true,"dg-permalink":"/408/Cache缺失竟对CPU寄存器暗送秋波😡","permalink":"/408/Cache缺失竟对CPU寄存器暗送秋波😡/"}
---


### 一、 流程图的直接证据：不存在“二次读取”

![56ebde223774065e8a3a657b3e381e15.png](/img/user/%E9%99%84%E4%BB%B6/56ebde223774065e8a3a657b3e381e15.png)
当**“从主存取出AD所在块”**这个耗时最长的操作完成之后，流程图的箭头**分叉了**！

它分成了两条并行的路径：

- **路径 A（通往CPU）**：**`将 AD 单元内容送 CPU`**
    
- **路径 B（通往Cache）**：**`在 cache 中找到一个对应的空闲行`** → **`将主存块复制到 cache 空闲行中`**
    

这两条路径最终都指向**“结束”**。

**这张图用最直观的方式告诉我们：**

> 在处理Cache缺失时，从主存取回的数据块被**同时**送往了两个目的地。其中，CPU当前急需的那个特定单元（或字）的内容，被直接“抄近道”送给了CPU；而整个数据块，则被写入到Cache中对应的空行里。

- “Cache处理时间”包括了什么？
    
    它包括了虚线框内的所有操作。主要是“从主存取块”的延迟，以及后续并行处理的耗时。它是一个从“判断出未命中”到“CPU拿到数据且Cache完成或开始填充”的总时间。
    
- 需要再重新读一遍Cache吗？
    
    绝对不需要。 流程图中没有任何一个箭头，是从“将主存块复制到cache”这一步再指回到“从cache中取信息送CPU”的。两条路径是并行的，CPU拿到数据后，整个访存操作就对CPU而言结束了，它可以继续执行下一条指令了。让CPU在Cache填充完毕后再来读一次，是一种极其低效的设计，现代处理器不会这么做。
    
