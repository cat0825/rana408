---
{"dg-publish":true,"dg-permalink":"/408/在隐含寻址中第二操作数是怎么在ACC当中金屋藏娇呢🤔","permalink":"/408/在隐含寻址中第二操作数是怎么在ACC当中金屋藏娇呢🤔/"}
---


### 一、 答案

累加器ACC中的数据，是在执行这条隐含寻址指令**之前**，由另一条加载指令（如 `LDA`）从内存或其它地方送入的。

### 二、 相关原理或操作过程的详细讲解

要理解ACC中的值“何时进去”，我们必须明白，一条独立的指令通常只完成一个原子性的操作。将数据从内存加载到ACC，和利用ACC中的数据进行运算，是两条不同的指令完成的。

这个过程通常分为两步，我们以一个典型的单累加器结构的CPU为例，计算表达式 `C = A + B` (假设A, B, C是内存地址)。

**第1步：加载操作数（让数据“进去”）**

CPU首先需要执行一条**加载指令 (Load)**，把第一个操作数从内存地址 `A` 拿出来，送到累加器ACC中。

- **指令：** `LDA A`
    
    - `LDA` 是 "LoaD Accumulator" 的缩写，是操作码。
        
    - `A` 是地址码，采用直接寻址方式，指明了操作数在主存中的位置。
        
- **执行过程：**
    
    1. CPU读取并译码 `LDA A` 指令。
        
    2. CPU通过地址总线发送地址 `A`。
        
    3. 主存根据地址 `A` 找到对应的数据 `M(A)`。
        
    4. 主存将数据 `M(A)` 通过数据总线返回给CPU。
        
    5. CPU将接收到的数据 `M(A)` 打入（写入）到累加器ACC中。
        

**至此，第一个操作数已经进入了ACC。这是对您“何时进去”这个问题的直接回答。**

**第2步：执行隐含寻址指令**

现在ACC中已经有了来自 `A` 的值，接下来CPU执行加法指令。

- **指令：** `ADD B`
    
    - `ADD` 是加法操作码。
        
    - `B` 是地址码，采用直接寻址，指明了第二个操作数的位置。
        
- **执行过程：**
    
    1. CPU读取并译码 `ADD B` 指令。操作码 `ADD` 在这种体系结构中**隐含约定**了：
        
        - 一个操作数已经存放在ACC中。
            
        - 另一个操作数需要从指令的地址码部分获取。
            
        - 运算结果将存回ACC中。
            
    2. CPU根据地址码 `B` 从主存中取出第二个操作数 `M(B)`。
        
    3. CPU内部的算术逻辑单元 (ALU) 将ACC的现存内容和从主存取出的 `M(B)` 相加。
        
    4. ALU将加法结果写回到ACC中，覆盖掉原来的值。
        

**整个流程的伪代码与ACC状态变化：**

| 汇编指令    | 操作解释                                 | ACC 内部值的变化                                |
| ------- | ------------------------------------ | ----------------------------------------- |
| `LDA A` | Load Accumulator: 将内存地址A处的值加载到ACC。   | `ACC` <- `M(A)`                           |
| `ADD B` | Add: 将ACC的值与内存地址B处的值相加，结果存回ACC。      | `ACC` <- `(ACC)` + `M(B)` (即 `M(A)+M(B)`) |
| `STA C` | Store Accumulator: 将ACC的当前值存入内存地址C处。 | `ACC` 内容不变，`M(C)` <- `(ACC)`              |

上图中，`ACC = M[A]` 这个状态就是ACC“进去”数据的时间点。


### 三、 边界情况、易错点、反例

- **纯粹的隐含寻址：** 有些指令甚至不包含任何地址码字段，它们的操作数完全是隐含的。
    
    - **例：** `CMA` (Complement Accumulator，累加器取反)。这条指令只有一个操作码，它默认对ACC的内容进行按位取反，结果仍存回ACC。这里，源操作数和目的操作数都是ACC，且都被隐含了。
        
    - **例：** 堆栈操作中的 `PUSH` 和 `POP` 指令。它们隐含使用了栈顶指针 `SP` 来作为内存操作的地址。例如 `PUSH AX`，指令只说了要把 `AX` 的内容入栈，但入到哪里去呢？这个地址是由 `SP` 寄存器隐含提供的。
        
- **易错点：** 将单地址指令与隐含寻址划等号。
    
    - 单地址指令 `OP Addr`（如 `ADD B`）确实使用了隐含寻址（隐含了ACC），但它的另一个操作数 `M(B)` 却采用了**直接寻址**。一条指令可以组合多种寻址方式。考题若问“ADD B指令使用了哪种寻址方式？”，严谨的答案是“隐含寻址和直接寻址”。如果选项中只有其一，通常是考察其最核心的特征，即作为单地址指令对ACC的隐含使用。
        